2023-08-19 12:24:47:443 grammar LogManager.java:25 before: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-19 12:24:47:462 grammar LogManager.java:25 after: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-19 12:24:48:207 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (BLOCK (ALT '*') (ALT '/')) expr) (ALT expr (BLOCK (ALT '+') (ALT '-')) expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-19 12:24:48:208 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-19 12:24:48:209 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')')))))
2023-08-19 12:24:48:209 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (RULES (RULE T__0 (BLOCK (ALT '*'))) (RULE T__1 (BLOCK (ALT '/'))) (RULE T__2 (BLOCK (ALT '+'))) (RULE T__3 (BLOCK (ALT '-'))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-19 12:24:48:293 left-recursion LogManager.java:25 expr
    :   ( {} INT<tokenIndex=44> 
        | '('<tokenIndex=48> expr<tokenIndex=50> ')'<tokenIndex=52> 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> ('*'<tokenIndex=23>|'/'<tokenIndex=25>) expr<tokenIndex=28,p=5>
                  | {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> ('+'<tokenIndex=35>|'-'<tokenIndex=37>) expr<tokenIndex=40,p=4>
        )*
    ;
2023-08-19 12:24:48:298 grammar LogManager.java:25 added: (RULE expr (BLOCK (ALT (BLOCK (ALT {} (INT (ELEMENT_OPTIONS (= tokenIndex 44)))) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 48))) (expr (ELEMENT_OPTIONS (= tokenIndex 50))) (')' (ELEMENT_OPTIONS (= tokenIndex 52))))) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 23))) ('/' (ELEMENT_OPTIONS (= tokenIndex 25)))) (expr (ELEMENT_OPTIONS (= tokenIndex 28) (= p 5)))) (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 35))) ('-' (ELEMENT_OPTIONS (= tokenIndex 37)))) (expr (ELEMENT_OPTIONS (= tokenIndex 40) (= p 4)))))))))
2023-08-19 12:24:48:299 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, NEWLINE=7, INT=8}
2023-08-19 12:24:48:299 semantics LogManager.java:25 strings={'*'=1, '/'=2, '+'=3, '-'=4, '('=5, ')'=6}
2023-08-19 12:24:48:310 LL1 LogManager.java:25 
DECISION 0 in rule prog
2023-08-19 12:24:48:310 LL1 LogManager.java:25 look=[{5, 8}, <EOF>]
2023-08-19 12:24:48:312 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:312 LL1 LogManager.java:25 
DECISION 1 in rule expr
2023-08-19 12:24:48:312 LL1 LogManager.java:25 look=[8, 5]
2023-08-19 12:24:48:312 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:312 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-08-19 12:24:48:312 LL1 LogManager.java:25 look=[null, null]
2023-08-19 12:24:48:312 LL1 LogManager.java:25 LL(1)? false
2023-08-19 12:24:48:312 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-08-19 12:24:48:312 LL1 LogManager.java:25 look=[null, null]
2023-08-19 12:24:48:312 LL1 LogManager.java:25 LL(1)? false
2023-08-19 12:24:48:329 action-translator LogManager.java:25 translate 
2023-08-19 12:24:48:330 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-19 12:24:48:331 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-19 12:24:48:332 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-19 12:24:48:332 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-19 12:24:48:652 grammar LogManager.java:25 load Swiftlex from Swiftgramm.g4
2023-08-19 12:24:48:654 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-19 12:24:48:655 grammar LogManager.java:25 imported actions: []
2023-08-19 12:24:48:660 grammar LogManager.java:25 Swiftgramm parser:header={
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}
2023-08-19 12:24:48:660 grammar LogManager.java:25 Swiftgramm parser:init={
        $blk = []interface{}{}
        var listInt []ISentenceContext
}
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE INT (BLOCK (ALT 'Int')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE FLOAT (BLOCK (ALT 'Float')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE STRING (BLOCK (ALT 'String')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE BOOL (BLOCK (ALT 'Bool')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CHARACTER (BLOCK (ALT 'Character')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE TRUE (BLOCK (ALT 'true')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE FALSE (BLOCK (ALT 'false')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE NIL (BLOCK (ALT 'nil')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE VAR (BLOCK (ALT 'var')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE LET (BLOCK (ALT 'let')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE PRINT (BLOCK (ALT 'print')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE IF (BLOCK (ALT 'if')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE ELSE (BLOCK (ALT 'else')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE SWITCH (BLOCK (ALT 'switch')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CASE (BLOCK (ALT 'case')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE BREAK (BLOCK (ALT 'break')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE DEFAULT (BLOCK (ALT 'default')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE WHILE (BLOCK (ALT 'while')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE FOR (BLOCK (ALT 'for')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE IN (BLOCK (ALT 'in')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE GUARD (BLOCK (ALT 'guard')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CONTINUE (BLOCK (ALT 'continue')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE RETURN (BLOCK (ALT 'return')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE FUNC (BLOCK (ALT 'func')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE STRUCT (BLOCK (ALT 'struct')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE MUTATING (BLOCK (ALT 'mutating')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE SELF (BLOCK (ALT 'self')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE INOUT (BLOCK (ALT 'inout')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9])))))))))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_]))))))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE SUMMATION (BLOCK (ALT '+')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE SUBTRACTION (BLOCK (ALT '-')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE MULTIPLICATION (BLOCK (ALT '*')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE DIVISION (BLOCK (ALT '/')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE MOD (BLOCK (ALT '%')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE QUESTION_MARK (BLOCK (ALT '?')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE OR (BLOCK (ALT '||')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE AND (BLOCK (ALT '&&')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE NOT (BLOCK (ALT '!')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE EQUAL (BLOCK (ALT '==')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE NOT_EQUAL (BLOCK (ALT '!=')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE LESS_THAN (BLOCK (ALT '<')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE LESS_THAN_EQUAL (BLOCK (ALT '<=')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN (BLOCK (ALT '>')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>=')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE ASSIGN (BLOCK (ALT '=')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE DOT (BLOCK (ALT '.')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE COMMA (BLOCK (ALT ',')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE COLON (BLOCK (ALT ':')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE SEMICOLON (BLOCK (ALT ';')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE OPEN_PARENTHESIS (BLOCK (ALT '(')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE OPEN_kEY (BLOCK (ALT '{')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE CLOSE_kEY (BLOCK (ALT '}')))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip)))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip)))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))
2023-08-19 12:24:48:660 grammar LogManager.java:25 imported rule: (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))
2023-08-19 12:24:48:661 grammar LogManager.java:25 Grammar: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-19 12:24:48:668 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression)) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-19 12:24:48:670 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression)) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-19 12:24:48:670 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftgrammLexer (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-19 12:24:48:687 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:48:813 left-recursion LogManager.java:25 expression returns [abstract.Expression p]
    :   ( {} OPEN_PARENTHESIS<tokenIndex=241> expression<tokenIndex=243> CLOSE_PARENTHESIS<tokenIndex=245> 
        | NUMBER<tokenIndex=249>{
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        } 
        | FLOATT<tokenIndex=254>{
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        } 
        | STRING_LITERAL<tokenIndex=259>{
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        } 
        | CHARACTER_LITERAL<tokenIndex=264>{
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        } 
        | TRUE<tokenIndex=269>{
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | FALSE<tokenIndex=274>{
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | ID<tokenIndex=279>{
                $p = expressions.NewIdentifier($ID.text)
        } 
        | NIL<tokenIndex=284>{
                $p = expressions.NewNative(nil,symbol.NIL)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> oper=(MULTIPLICATION<tokenIndex=157>|DIVISION<tokenIndex=159>) right=expression<tokenIndex=164,p=15>
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> oper=(SUMMATION<tokenIndex=175>|SUBTRACTION<tokenIndex=177>) right=expression<tokenIndex=182,p=14>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> oper=(LESS_THAN<tokenIndex=194>|LESS_THAN_EQUAL<tokenIndex=196>) right=expression<tokenIndex=201,p=13>
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> oper=(GREATER_THAN<tokenIndex=212>|GREATER_THAN_EQUAL<tokenIndex=214>) right=expression<tokenIndex=219,p=12>
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> oper=(EQUAL<tokenIndex=230>|NOT_EQUAL<tokenIndex=232>) right=expression<tokenIndex=237,p=11>
        )*
    ;
2023-08-19 12:24:48:818 grammar LogManager.java:25 added: (RULE expression (returns abstract.Expression p) (BLOCK (ALT (BLOCK (ALT {} (OPEN_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 241))) (expression (ELEMENT_OPTIONS (= tokenIndex 243))) (CLOSE_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 245)))) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 249))) {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT (FLOATT (ELEMENT_OPTIONS (= tokenIndex 254))) {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT (STRING_LITERAL (ELEMENT_OPTIONS (= tokenIndex 259))) {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT (CHARACTER_LITERAL (ELEMENT_OPTIONS (= tokenIndex 264))) {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 269))) {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 274))) {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 279))) {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 284))) {
                $p = expressions.NewNative(nil,symbol.NIL)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= oper (SET (MULTIPLICATION (ELEMENT_OPTIONS (= tokenIndex 157))) (DIVISION (ELEMENT_OPTIONS (= tokenIndex 159))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 164) (= p 15))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= oper (SET (SUMMATION (ELEMENT_OPTIONS (= tokenIndex 175))) (SUBTRACTION (ELEMENT_OPTIONS (= tokenIndex 177))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 182) (= p 14)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= oper (SET (LESS_THAN (ELEMENT_OPTIONS (= tokenIndex 194))) (LESS_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 196))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 201) (= p 13))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= oper (SET (GREATER_THAN (ELEMENT_OPTIONS (= tokenIndex 212))) (GREATER_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 214))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 219) (= p 12))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= oper (SET (EQUAL (ELEMENT_OPTIONS (= tokenIndex 230))) (NOT_EQUAL (ELEMENT_OPTIONS (= tokenIndex 232))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 237) (= p 11))))))))))
2023-08-19 12:24:48:820 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACTER=5, TRUE=6, FALSE=7, NIL=8, VAR=9, LET=10, PRINT=11, IF=12, ELSE=13, SWITCH=14, CASE=15, BREAK=16, DEFAULT=17, WHILE=18, FOR=19, IN=20, GUARD=21, CONTINUE=22, RETURN=23, FUNC=24, STRUCT=25, MUTATING=26, SELF=27, INOUT=28, NUMBER=29, FLOATT=30, STRING_LITERAL=31, ID=32, CHARACTER_LITERAL=33, SUMMATION=34, SUBTRACTION=35, MULTIPLICATION=36, DIVISION=37, MOD=38, QUESTION_MARK=39, OR=40, AND=41, NOT=42, EQUAL=43, NOT_EQUAL=44, LESS_THAN=45, LESS_THAN_EQUAL=46, GREATER_THAN=47, GREATER_THAN_EQUAL=48, ASSIGN=49, DOT=50, COMMA=51, COLON=52, SEMICOLON=53, OPEN_PARENTHESIS=54, CLOSE_PARENTHESIS=55, OPEN_kEY=56, CLOSE_kEY=57, WHITESPACE=58, COMMENT=59, LINE_COMMENT=60}
2023-08-19 12:24:48:821 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'nil'=8, 'var'=9, 'let'=10, 'print'=11, 'if'=12, 'else'=13, 'switch'=14, 'case'=15, 'break'=16, 'default'=17, 'while'=18, 'for'=19, 'in'=20, 'guard'=21, 'continue'=22, 'return'=23, 'func'=24, 'struct'=25, 'mutating'=26, 'self'=27, 'inout'=28, '+'=34, '-'=35, '*'=36, '/'=37, '%'=38, '?'=39, '||'=40, '&&'=41, '!'=42, '=='=43, '!='=44, '<'=45, '<='=46, '>'=47, '>='=48, '='=49, '.'=50, ','=51, ':'=52, ';'=53, '('=54, ')'=55, '{'=56, '}'=57}
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[{9, 11}, <EOF>]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 1 in rule sentence
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[9, 11]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 2 in rule declare_var
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[9, 9, 9]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? false
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 3 in rule expression
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[54, 29, 30, 31, 33, 6, 7, 32, 8]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 4 in rule expression
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[null, null, null, null, null]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? false
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 5 in rule expression
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[null, null]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? false
2023-08-19 12:24:48:829 LL1 LogManager.java:25 
DECISION 6 in rule datatype
2023-08-19 12:24:48:829 LL1 LogManager.java:25 look=[1, 2, 31, 4, 33]
2023-08-19 12:24:48:829 LL1 LogManager.java:25 LL(1)? true
2023-08-19 12:24:48:829 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:48:831 action-translator LogManager.java:25 translate 
        $code = $block.blk

2023-08-19 12:24:48:831 action-translator LogManager.java:25 attr [@-1,11:14='code',<0>,12:9]
2023-08-19 12:24:48:832 action-translator LogManager.java:25 qattr [@-1,19:23='block',<0>,12:17].[@-1,25:27='blk',<0>,12:23]
2023-08-19 12:24:48:833 action-translator LogManager.java:25 translate 
        $blk = []interface{}{}
        var listInt []ISentenceContext

2023-08-19 12:24:48:833 action-translator LogManager.java:25 attr [@-1,11:13='blk',<0>,18:9]
2023-08-19 12:24:48:833 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }

2023-08-19 12:24:48:833 action-translator LogManager.java:25 attr [@-1,109:111='blk',<0>,25:17]
2023-08-19 12:24:48:833 action-translator LogManager.java:25 attr [@-1,123:125='blk',<0>,25:31]
2023-08-19 12:24:48:835 action-translator LogManager.java:25 translate $instr = $declare_var.instr
2023-08-19 12:24:48:835 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,30:23]
2023-08-19 12:24:48:835 action-translator LogManager.java:25 qattr [@-1,10:20='declare_var',<0>,30:32].[@-1,22:26='instr',<0>,30:44]
2023-08-19 12:24:48:835 action-translator LogManager.java:25 translate $instr = $print_bl.instr
2023-08-19 12:24:48:835 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,31:20]
2023-08-19 12:24:48:835 action-translator LogManager.java:25 qattr [@-1,10:17='print_bl',<0>,31:29].[@-1,19:23='instr',<0>,31:38]
2023-08-19 12:24:48:836 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                
2023-08-19 12:24:48:837 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,39:25]
2023-08-19 12:24:48:837 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,39:67].[@-1,72:75='text',<0>,39:70]
2023-08-19 12:24:48:837 action-translator LogManager.java:25 qattr [@-1,78:85='datatype',<0>,39:76].[@-1,87:88='td',<0>,39:85]
2023-08-19 12:24:48:837 action-translator LogManager.java:25 qattr [@-1,91:100='expression',<0>,39:89].[@-1,102:102='p',<0>,39:100]
2023-08-19 12:24:48:837 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                
2023-08-19 12:24:48:837 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,42:25]
2023-08-19 12:24:48:838 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,42:67].[@-1,72:75='text',<0>,42:70]
2023-08-19 12:24:48:838 action-translator LogManager.java:25 qattr [@-1,95:104='expression',<0>,42:93].[@-1,106:106='p',<0>,42:104]
2023-08-19 12:24:48:838 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                
2023-08-19 12:24:48:838 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,45:25]
2023-08-19 12:24:48:838 action-translator LogManager.java:25 qattr [@-1,72:73='ID',<0>,45:70].[@-1,75:78='text',<0>,45:73]
2023-08-19 12:24:48:838 action-translator LogManager.java:25 qattr [@-1,81:88='datatype',<0>,45:79].[@-1,90:91='td',<0>,45:88]
2023-08-19 12:24:48:840 action-translator LogManager.java:25 translate 
        $instr = instructions.NewPrint($expression.p)

2023-08-19 12:24:48:840 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,52:9]
2023-08-19 12:24:48:840 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,52:40].[@-1,53:53='p',<0>,52:51]
2023-08-19 12:24:48:841 action-translator LogManager.java:25 translate 
2023-08-19 12:24:48:841 action-translator LogManager.java:25 translate 
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        
2023-08-19 12:24:48:841 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,4:43].[@-1,52:55='text',<0>,4:50]
2023-08-19 12:24:48:842 action-translator LogManager.java:25 attr [@-1,169:169='p',<0>,8:17]
2023-08-19 12:24:48:842 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        
2023-08-19 12:24:48:842 action-translator LogManager.java:25 qattr [@-1,51:56='FLOATT',<0>,11:49].[@-1,58:61='text',<0>,11:56]
2023-08-19 12:24:48:842 action-translator LogManager.java:25 attr [@-1,178:178='p',<0>,15:17]
2023-08-19 12:24:48:842 action-translator LogManager.java:25 translate 
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        
2023-08-19 12:24:48:842 action-translator LogManager.java:25 qattr [@-1,28:41='STRING_LITERAL',<0>,18:26].[@-1,43:46='text',<0>,18:41]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 qattr [@-1,55:68='STRING_LITERAL',<0>,18:53].[@-1,70:73='text',<0>,18:68]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 attr [@-1,97:97='p',<0>,19:17]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 translate 
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        
2023-08-19 12:24:48:843 action-translator LogManager.java:25 qattr [@-1,28:44='CHARACTER_LITERAL',<0>,22:26].[@-1,46:49='text',<0>,22:44]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 qattr [@-1,58:74='CHARACTER_LITERAL',<0>,22:56].[@-1,76:79='text',<0>,22:74]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,23:17]
2023-08-19 12:24:48:843 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-19 12:24:48:843 action-translator LogManager.java:25 qattr [@-1,50:53='TRUE',<0>,26:48].[@-1,55:58='text',<0>,26:53]
2023-08-19 12:24:48:844 action-translator LogManager.java:25 attr [@-1,172:172='p',<0>,30:17]
2023-08-19 12:24:48:844 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-19 12:24:48:844 action-translator LogManager.java:25 qattr [@-1,50:54='FALSE',<0>,33:48].[@-1,56:59='text',<0>,33:54]
2023-08-19 12:24:48:844 action-translator LogManager.java:25 attr [@-1,173:173='p',<0>,37:17]
2023-08-19 12:24:48:844 action-translator LogManager.java:25 translate 
                $p = expressions.NewIdentifier($ID.text)
        
2023-08-19 12:24:48:844 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,40:17]
2023-08-19 12:24:48:844 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,40:48].[@-1,53:56='text',<0>,40:51]
2023-08-19 12:24:48:845 action-translator LogManager.java:25 translate 
                $p = expressions.NewNative(nil,symbol.NIL)
        
2023-08-19 12:24:48:845 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,43:17]
2023-08-19 12:24:48:845 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-19 12:24:48:845 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-19 12:24:48:845 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-19 12:24:48:846 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,49:27]
2023-08-19 12:24:48:846 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,49:68].[@-1,75:75='p',<0>,49:73]
2023-08-19 12:24:48:846 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,49:76].[@-1,84:84='p',<0>,49:82]
2023-08-19 12:24:48:846 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,49:85].[@-1,92:95='text',<0>,49:90]
2023-08-19 12:24:48:846 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-19 12:24:48:846 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-19 12:24:48:847 action-translator LogManager.java:25 translate 
                $td = symbol.INT
        
2023-08-19 12:24:48:849 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,112:17]
2023-08-19 12:24:48:849 action-translator LogManager.java:25 translate 
                $td = symbol.FLOAT
        
2023-08-19 12:24:48:849 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,115:17]
2023-08-19 12:24:48:849 action-translator LogManager.java:25 translate 
                $td = symbol.STRING
        
2023-08-19 12:24:48:849 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,118:17]
2023-08-19 12:24:48:849 action-translator LogManager.java:25 translate 
                $td = symbol.BOOL
        
2023-08-19 12:24:48:849 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,121:17]
2023-08-19 12:24:48:849 action-translator LogManager.java:25 translate 
                $td = symbol.CHAR
        
2023-08-19 12:24:48:849 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,124:17]
2023-08-19 12:24:48:992 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:48:992 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:054 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:054 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:119 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:119 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:175 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-19 12:24:49:175 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

