2023-08-12 07:54:32:866 grammar LogManager.java:25 before: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-12 07:54:32:886 grammar LogManager.java:25 after: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-12 07:54:33:296 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (BLOCK (ALT '*') (ALT '/')) expr) (ALT expr (BLOCK (ALT '+') (ALT '-')) expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-12 07:54:33:298 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-12 07:54:33:299 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')')))))
2023-08-12 07:54:33:299 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (RULES (RULE T__0 (BLOCK (ALT '*'))) (RULE T__1 (BLOCK (ALT '/'))) (RULE T__2 (BLOCK (ALT '+'))) (RULE T__3 (BLOCK (ALT '-'))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-12 07:54:33:360 left-recursion LogManager.java:25 expr
    :   ( {} INT<tokenIndex=44> 
        | '('<tokenIndex=48> expr<tokenIndex=50> ')'<tokenIndex=52> 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> ('*'<tokenIndex=23>|'/'<tokenIndex=25>) expr<tokenIndex=28,p=5>
                  | {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> ('+'<tokenIndex=35>|'-'<tokenIndex=37>) expr<tokenIndex=40,p=4>
        )*
    ;
2023-08-12 07:54:33:365 grammar LogManager.java:25 added: (RULE expr (BLOCK (ALT (BLOCK (ALT {} (INT (ELEMENT_OPTIONS (= tokenIndex 44)))) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 48))) (expr (ELEMENT_OPTIONS (= tokenIndex 50))) (')' (ELEMENT_OPTIONS (= tokenIndex 52))))) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 23))) ('/' (ELEMENT_OPTIONS (= tokenIndex 25)))) (expr (ELEMENT_OPTIONS (= tokenIndex 28) (= p 5)))) (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 35))) ('-' (ELEMENT_OPTIONS (= tokenIndex 37)))) (expr (ELEMENT_OPTIONS (= tokenIndex 40) (= p 4)))))))))
2023-08-12 07:54:33:365 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, NEWLINE=7, INT=8}
2023-08-12 07:54:33:366 semantics LogManager.java:25 strings={'*'=1, '/'=2, '+'=3, '-'=4, '('=5, ')'=6}
2023-08-12 07:54:33:377 LL1 LogManager.java:25 
DECISION 0 in rule prog
2023-08-12 07:54:33:377 LL1 LogManager.java:25 look=[{5, 8}, <EOF>]
2023-08-12 07:54:33:377 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:377 LL1 LogManager.java:25 
DECISION 1 in rule expr
2023-08-12 07:54:33:377 LL1 LogManager.java:25 look=[8, 5]
2023-08-12 07:54:33:377 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:377 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-08-12 07:54:33:378 LL1 LogManager.java:25 look=[null, null]
2023-08-12 07:54:33:378 LL1 LogManager.java:25 LL(1)? false
2023-08-12 07:54:33:378 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-08-12 07:54:33:378 LL1 LogManager.java:25 look=[null, null]
2023-08-12 07:54:33:378 LL1 LogManager.java:25 LL(1)? false
2023-08-12 07:54:33:397 action-translator LogManager.java:25 translate 
2023-08-12 07:54:33:398 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-12 07:54:33:399 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-12 07:54:33:400 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-12 07:54:33:400 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-12 07:54:33:705 grammar LogManager.java:25 load Swiftlex from Swiftgramm.g4
2023-08-12 07:54:33:709 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        fmt.Println("Variable declaration: ");
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression) (ALT VAR ID COLON datatype QUESTION_MARK))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOATT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-12 07:54:33:709 grammar LogManager.java:25 imported actions: []
2023-08-12 07:54:33:714 grammar LogManager.java:25 Swiftgramm parser:header={
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}
2023-08-12 07:54:33:714 grammar LogManager.java:25 Swiftgramm parser:init={
        $blk = []interface{}{}
        var listInt []ISentenceContext
}
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE INT (BLOCK (ALT 'Int')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE FLOAT (BLOCK (ALT 'Float')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE STRING (BLOCK (ALT 'String')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE BOOL (BLOCK (ALT 'Bool')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CHARACTER (BLOCK (ALT 'Character')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE TRUE (BLOCK (ALT 'true')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE FALSE (BLOCK (ALT 'false')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE NIL (BLOCK (ALT 'nil')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE VAR (BLOCK (ALT 'var')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE LET (BLOCK (ALT 'let')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE PRINT (BLOCK (ALT 'print')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE IF (BLOCK (ALT 'if')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE ELSE (BLOCK (ALT 'else')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE SWITCH (BLOCK (ALT 'switch')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CASE (BLOCK (ALT 'case')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE BREAK (BLOCK (ALT 'break')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE DEFAULT (BLOCK (ALT 'default')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE WHILE (BLOCK (ALT 'while')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE FOR (BLOCK (ALT 'for')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE IN (BLOCK (ALT 'in')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE GUARD (BLOCK (ALT 'guard')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CONTINUE (BLOCK (ALT 'continue')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE RETURN (BLOCK (ALT 'return')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE FUNC (BLOCK (ALT 'func')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE STRUCT (BLOCK (ALT 'struct')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE MUTATING (BLOCK (ALT 'mutating')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE SELF (BLOCK (ALT 'self')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE INOUT (BLOCK (ALT 'inout')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9])))))))))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_]))))))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE SUMMATION (BLOCK (ALT '+')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE SUBTRACTION (BLOCK (ALT '-')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE MULTIPLICATION (BLOCK (ALT '*')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE DIVISION (BLOCK (ALT '/')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE MOD (BLOCK (ALT '%')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE QUESTION_MARK (BLOCK (ALT '?')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE OR (BLOCK (ALT '||')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE AND (BLOCK (ALT '&&')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE NOT (BLOCK (ALT '!')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE EQUAL (BLOCK (ALT '==')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE NOT_EQUAL (BLOCK (ALT '!=')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE LESS_THAN (BLOCK (ALT '<')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE LESS_THAN_EQUAL (BLOCK (ALT '<=')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN (BLOCK (ALT '>')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>=')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE ASSIGN (BLOCK (ALT '=')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE DOT (BLOCK (ALT '.')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE COMMA (BLOCK (ALT ',')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE COLON (BLOCK (ALT ':')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE SEMICOLON (BLOCK (ALT ';')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE OPEN_PARENTHESIS (BLOCK (ALT '(')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE OPEN_kEY (BLOCK (ALT '{')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE CLOSE_kEY (BLOCK (ALT '}')))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip)))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip)))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))
2023-08-12 07:54:33:715 grammar LogManager.java:25 imported rule: (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))
2023-08-12 07:54:33:716 grammar LogManager.java:25 Grammar: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        fmt.Println("Variable declaration: ");
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression) (ALT VAR ID COLON datatype QUESTION_MARK))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression)) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOATT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-12 07:54:33:721 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        fmt.Println("Variable declaration: ");
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression) (ALT VAR ID COLON datatype QUESTION_MARK))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression)) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression)) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOATT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-12 07:54:33:722 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT print_bl {$instr = $print_bl.instr}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        fmt.Println("Variable declaration: ");
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression) (ALT VAR ID COLON datatype QUESTION_MARK))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression)) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression)) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression)) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression)) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOATT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-12 07:54:33:722 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftgrammLexer (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-12 07:54:33:734 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:33:835 left-recursion LogManager.java:25 expression returns [abstract.Expression p]
    :   ( {} OPEN_PARENTHESIS<tokenIndex=238> expression<tokenIndex=240> CLOSE_PARENTHESIS<tokenIndex=242> 
        | NUMBER<tokenIndex=246>{
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        } 
        | STRING_LITERAL<tokenIndex=251>{
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        } 
        | CHARACTER_LITERAL<tokenIndex=256>{
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        } 
        | TRUE<tokenIndex=261>{
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | FALSE<tokenIndex=266>{
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | ID<tokenIndex=271>{
                $p = expressions.NewIdentifier($ID.text)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> oper=(MULTIPLICATION<tokenIndex=155>|DIVISION<tokenIndex=157>) right=expression<tokenIndex=162,p=13>
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> oper=(SUMMATION<tokenIndex=173>|SUBTRACTION<tokenIndex=175>) right=expression<tokenIndex=180,p=12>
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> oper=(LESS_THAN<tokenIndex=191>|LESS_THAN_EQUAL<tokenIndex=193>) right=expression<tokenIndex=198,p=11>
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> oper=(GREATER_THAN<tokenIndex=209>|GREATER_THAN_EQUAL<tokenIndex=211>) right=expression<tokenIndex=216,p=10>
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> oper=(EQUAL<tokenIndex=227>|NOT_EQUAL<tokenIndex=229>) right=expression<tokenIndex=234,p=9>
        )*
    ;
2023-08-12 07:54:33:841 grammar LogManager.java:25 added: (RULE expression (returns abstract.Expression p) (BLOCK (ALT (BLOCK (ALT {} (OPEN_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 238))) (expression (ELEMENT_OPTIONS (= tokenIndex 240))) (CLOSE_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 242)))) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 246))) {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT (STRING_LITERAL (ELEMENT_OPTIONS (= tokenIndex 251))) {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT (CHARACTER_LITERAL (ELEMENT_OPTIONS (= tokenIndex 256))) {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 261))) {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 266))) {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 271))) {
                $p = expressions.NewIdentifier($ID.text)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= oper (SET (MULTIPLICATION (ELEMENT_OPTIONS (= tokenIndex 155))) (DIVISION (ELEMENT_OPTIONS (= tokenIndex 157))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 162) (= p 13))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= oper (SET (SUMMATION (ELEMENT_OPTIONS (= tokenIndex 173))) (SUBTRACTION (ELEMENT_OPTIONS (= tokenIndex 175))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 180) (= p 12))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= oper (SET (LESS_THAN (ELEMENT_OPTIONS (= tokenIndex 191))) (LESS_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 193))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 198) (= p 11))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= oper (SET (GREATER_THAN (ELEMENT_OPTIONS (= tokenIndex 209))) (GREATER_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 211))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 216) (= p 10))))) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= oper (SET (EQUAL (ELEMENT_OPTIONS (= tokenIndex 227))) (NOT_EQUAL (ELEMENT_OPTIONS (= tokenIndex 229))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 234) (= p 9))))))))))
2023-08-12 07:54:33:841 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACTER=5, TRUE=6, FALSE=7, NIL=8, VAR=9, LET=10, PRINT=11, IF=12, ELSE=13, SWITCH=14, CASE=15, BREAK=16, DEFAULT=17, WHILE=18, FOR=19, IN=20, GUARD=21, CONTINUE=22, RETURN=23, FUNC=24, STRUCT=25, MUTATING=26, SELF=27, INOUT=28, NUMBER=29, FLOATT=30, STRING_LITERAL=31, ID=32, CHARACTER_LITERAL=33, SUMMATION=34, SUBTRACTION=35, MULTIPLICATION=36, DIVISION=37, MOD=38, QUESTION_MARK=39, OR=40, AND=41, NOT=42, EQUAL=43, NOT_EQUAL=44, LESS_THAN=45, LESS_THAN_EQUAL=46, GREATER_THAN=47, GREATER_THAN_EQUAL=48, ASSIGN=49, DOT=50, COMMA=51, COLON=52, SEMICOLON=53, OPEN_PARENTHESIS=54, CLOSE_PARENTHESIS=55, OPEN_kEY=56, CLOSE_kEY=57, WHITESPACE=58, COMMENT=59, LINE_COMMENT=60}
2023-08-12 07:54:33:841 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'nil'=8, 'var'=9, 'let'=10, 'print'=11, 'if'=12, 'else'=13, 'switch'=14, 'case'=15, 'break'=16, 'default'=17, 'while'=18, 'for'=19, 'in'=20, 'guard'=21, 'continue'=22, 'return'=23, 'func'=24, 'struct'=25, 'mutating'=26, 'self'=27, 'inout'=28, '+'=34, '-'=35, '*'=36, '/'=37, '%'=38, '?'=39, '||'=40, '&&'=41, '!'=42, '=='=43, '!='=44, '<'=45, '<='=46, '>'=47, '>='=48, '='=49, '.'=50, ','=51, ':'=52, ';'=53, '('=54, ')'=55, '{'=56, '}'=57}
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[{9, 11}, <EOF>]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 1 in rule sentence
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[9, 11]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 2 in rule declare_var
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[9, 9, 9]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? false
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 3 in rule expression
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[54, 29, 31, 33, 6, 7, 32]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 4 in rule expression
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[null, null, null, null, null]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? false
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 5 in rule expression
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[null, null]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? false
2023-08-12 07:54:33:850 LL1 LogManager.java:25 
DECISION 6 in rule datatype
2023-08-12 07:54:33:850 LL1 LogManager.java:25 look=[1, 30, 31, 4, 33]
2023-08-12 07:54:33:850 LL1 LogManager.java:25 LL(1)? true
2023-08-12 07:54:33:850 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:33:852 action-translator LogManager.java:25 translate 
        $code = $block.blk

2023-08-12 07:54:33:852 action-translator LogManager.java:25 attr [@-1,11:14='code',<0>,12:9]
2023-08-12 07:54:33:852 action-translator LogManager.java:25 qattr [@-1,19:23='block',<0>,12:17].[@-1,25:27='blk',<0>,12:23]
2023-08-12 07:54:33:854 action-translator LogManager.java:25 translate 
        $blk = []interface{}{}
        var listInt []ISentenceContext

2023-08-12 07:54:33:854 action-translator LogManager.java:25 attr [@-1,11:13='blk',<0>,18:9]
2023-08-12 07:54:33:855 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }

2023-08-12 07:54:33:855 action-translator LogManager.java:25 attr [@-1,109:111='blk',<0>,25:17]
2023-08-12 07:54:33:855 action-translator LogManager.java:25 attr [@-1,123:125='blk',<0>,25:31]
2023-08-12 07:54:33:856 action-translator LogManager.java:25 translate $instr = $declare_var.instr
2023-08-12 07:54:33:856 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,30:23]
2023-08-12 07:54:33:856 action-translator LogManager.java:25 qattr [@-1,10:20='declare_var',<0>,30:32].[@-1,22:26='instr',<0>,30:44]
2023-08-12 07:54:33:856 action-translator LogManager.java:25 translate $instr = $print_bl.instr
2023-08-12 07:54:33:856 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,31:20]
2023-08-12 07:54:33:856 action-translator LogManager.java:25 qattr [@-1,10:17='print_bl',<0>,31:29].[@-1,19:23='instr',<0>,31:38]
2023-08-12 07:54:33:857 action-translator LogManager.java:25 translate 
                        fmt.Println("Variable declaration: ");
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                
2023-08-12 07:54:33:857 action-translator LogManager.java:25 attr [@-1,91:95='instr',<0>,40:25]
2023-08-12 07:54:33:857 action-translator LogManager.java:25 qattr [@-1,133:134='ID',<0>,40:67].[@-1,136:139='text',<0>,40:70]
2023-08-12 07:54:33:858 action-translator LogManager.java:25 qattr [@-1,142:149='datatype',<0>,40:76].[@-1,151:152='td',<0>,40:85]
2023-08-12 07:54:33:858 action-translator LogManager.java:25 qattr [@-1,155:164='expression',<0>,40:89].[@-1,166:166='p',<0>,40:100]
2023-08-12 07:54:33:858 action-translator LogManager.java:25 translate 
        $instr = instructions.NewPrint($expression.p)

2023-08-12 07:54:33:858 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,49:9]
2023-08-12 07:54:33:858 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,49:40].[@-1,53:53='p',<0>,49:51]
2023-08-12 07:54:33:860 action-translator LogManager.java:25 translate 
2023-08-12 07:54:33:861 action-translator LogManager.java:25 translate 
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        
2023-08-12 07:54:33:862 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,4:43].[@-1,52:55='text',<0>,4:50]
2023-08-12 07:54:33:862 action-translator LogManager.java:25 attr [@-1,169:169='p',<0>,8:17]
2023-08-12 07:54:33:862 action-translator LogManager.java:25 translate 
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        
2023-08-12 07:54:33:862 action-translator LogManager.java:25 qattr [@-1,28:41='STRING_LITERAL',<0>,11:26].[@-1,43:46='text',<0>,11:41]
2023-08-12 07:54:33:862 action-translator LogManager.java:25 qattr [@-1,55:68='STRING_LITERAL',<0>,11:53].[@-1,70:73='text',<0>,11:68]
2023-08-12 07:54:33:862 action-translator LogManager.java:25 attr [@-1,97:97='p',<0>,12:17]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 translate 
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        
2023-08-12 07:54:33:863 action-translator LogManager.java:25 qattr [@-1,28:44='CHARACTER_LITERAL',<0>,15:26].[@-1,46:49='text',<0>,15:44]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 qattr [@-1,58:74='CHARACTER_LITERAL',<0>,15:56].[@-1,76:79='text',<0>,15:74]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,16:17]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-12 07:54:33:863 action-translator LogManager.java:25 qattr [@-1,50:53='TRUE',<0>,19:48].[@-1,55:58='text',<0>,19:53]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 attr [@-1,172:172='p',<0>,23:17]
2023-08-12 07:54:33:863 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-12 07:54:33:864 action-translator LogManager.java:25 qattr [@-1,50:54='FALSE',<0>,26:48].[@-1,56:59='text',<0>,26:54]
2023-08-12 07:54:33:864 action-translator LogManager.java:25 attr [@-1,173:173='p',<0>,30:17]
2023-08-12 07:54:33:864 action-translator LogManager.java:25 translate 
                $p = expressions.NewIdentifier($ID.text)
        
2023-08-12 07:54:33:864 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,33:17]
2023-08-12 07:54:33:864 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,33:48].[@-1,53:56='text',<0>,33:51]
2023-08-12 07:54:33:864 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-12 07:54:33:865 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-12 07:54:33:865 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-12 07:54:33:865 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 9)
2023-08-12 07:54:33:866 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 8)
2023-08-12 07:54:33:866 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-12 07:54:33:866 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-12 07:54:33:866 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-12 07:54:33:867 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 9)
2023-08-12 07:54:33:867 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 8)
2023-08-12 07:54:33:867 action-translator LogManager.java:25 translate 
                $td = symbol.INT
        
2023-08-12 07:54:33:867 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,97:17]
2023-08-12 07:54:33:868 action-translator LogManager.java:25 translate 
                $td = symbol.FLOAT
        
2023-08-12 07:54:33:868 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,100:17]
2023-08-12 07:54:33:868 action-translator LogManager.java:25 translate 
                $td = symbol.STRING
        
2023-08-12 07:54:33:868 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,103:17]
2023-08-12 07:54:33:868 action-translator LogManager.java:25 translate 
                $td = symbol.BOOL
        
2023-08-12 07:54:33:868 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,106:17]
2023-08-12 07:54:33:868 action-translator LogManager.java:25 translate 
                $td = symbol.CHAR
        
2023-08-12 07:54:33:868 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,109:17]
2023-08-12 07:54:33:987 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:33:987 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:037 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:037 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:083 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:083 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:136 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-12 07:54:34:136 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

