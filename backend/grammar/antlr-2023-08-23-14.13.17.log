2023-08-23 14:13:15:528 grammar LogManager.java:25 before: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 14:13:15:546 grammar LogManager.java:25 after: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 14:13:16:038 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (BLOCK (ALT '*') (ALT '/')) expr) (ALT expr (BLOCK (ALT '+') (ALT '-')) expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 14:13:16:041 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 14:13:16:042 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')')))))
2023-08-23 14:13:16:043 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (RULES (RULE T__0 (BLOCK (ALT '*'))) (RULE T__1 (BLOCK (ALT '/'))) (RULE T__2 (BLOCK (ALT '+'))) (RULE T__3 (BLOCK (ALT '-'))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 14:13:16:142 left-recursion LogManager.java:25 expr
    :   ( {} INT<tokenIndex=44> 
        | '('<tokenIndex=48> expr<tokenIndex=50> ')'<tokenIndex=52> 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> ('*'<tokenIndex=23>|'/'<tokenIndex=25>) expr<tokenIndex=28,p=5>
                  | {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> ('+'<tokenIndex=35>|'-'<tokenIndex=37>) expr<tokenIndex=40,p=4>
        )*
    ;
2023-08-23 14:13:16:147 grammar LogManager.java:25 added: (RULE expr (BLOCK (ALT (BLOCK (ALT {} (INT (ELEMENT_OPTIONS (= tokenIndex 44)))) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 48))) (expr (ELEMENT_OPTIONS (= tokenIndex 50))) (')' (ELEMENT_OPTIONS (= tokenIndex 52))))) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 23))) ('/' (ELEMENT_OPTIONS (= tokenIndex 25)))) (expr (ELEMENT_OPTIONS (= tokenIndex 28) (= p 5)))) (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 35))) ('-' (ELEMENT_OPTIONS (= tokenIndex 37)))) (expr (ELEMENT_OPTIONS (= tokenIndex 40) (= p 4)))))))))
2023-08-23 14:13:16:149 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, NEWLINE=7, INT=8}
2023-08-23 14:13:16:149 semantics LogManager.java:25 strings={'*'=1, '/'=2, '+'=3, '-'=4, '('=5, ')'=6}
2023-08-23 14:13:16:162 LL1 LogManager.java:25 
DECISION 0 in rule prog
2023-08-23 14:13:16:163 LL1 LogManager.java:25 look=[{5, 8}, <EOF>]
2023-08-23 14:13:16:163 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:163 LL1 LogManager.java:25 
DECISION 1 in rule expr
2023-08-23 14:13:16:163 LL1 LogManager.java:25 look=[8, 5]
2023-08-23 14:13:16:163 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:163 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-08-23 14:13:16:163 LL1 LogManager.java:25 look=[null, null]
2023-08-23 14:13:16:163 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:163 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-08-23 14:13:16:164 LL1 LogManager.java:25 look=[null, null]
2023-08-23 14:13:16:164 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:181 action-translator LogManager.java:25 translate 
2023-08-23 14:13:16:182 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-23 14:13:16:182 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-23 14:13:16:184 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-23 14:13:16:184 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-23 14:13:16:502 grammar LogManager.java:25 load Swiftlex from Swiftgramm.g4
2023-08-23 14:13:16:506 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p)
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-23 14:13:16:507 grammar LogManager.java:25 imported actions: []
2023-08-23 14:13:16:511 grammar LogManager.java:25 Swiftgramm parser:header={
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}
2023-08-23 14:13:16:511 grammar LogManager.java:25 Swiftgramm parser:init={
        $blk = []interface{}{}
        var listInt []ISentenceContext
}
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE INT (BLOCK (ALT 'Int')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE FLOAT (BLOCK (ALT 'Float')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE STRING (BLOCK (ALT 'String')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE BOOL (BLOCK (ALT 'Bool')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE CHARACTER (BLOCK (ALT 'Character')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE TRUE (BLOCK (ALT 'true')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE FALSE (BLOCK (ALT 'false')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE NIL (BLOCK (ALT 'nil')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE VAR (BLOCK (ALT 'var')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE LET (BLOCK (ALT 'let')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE PRINT (BLOCK (ALT 'print')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE IF (BLOCK (ALT 'if')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE ELSE (BLOCK (ALT 'else')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE SWITCH (BLOCK (ALT 'switch')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE CASE (BLOCK (ALT 'case')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE BREAK (BLOCK (ALT 'break')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE DEFAULT (BLOCK (ALT 'default')))
2023-08-23 14:13:16:511 grammar LogManager.java:25 imported rule: (RULE WHILE (BLOCK (ALT 'while')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE FOR (BLOCK (ALT 'for')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE IN (BLOCK (ALT 'in')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE GUARD (BLOCK (ALT 'guard')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE CONTINUE (BLOCK (ALT 'continue')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE RETURN (BLOCK (ALT 'return')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE FUNC (BLOCK (ALT 'func')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE STRUCT (BLOCK (ALT 'struct')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE MUTATING (BLOCK (ALT 'mutating')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE SELF (BLOCK (ALT 'self')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE INOUT (BLOCK (ALT 'inout')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9])))))))))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_]))))))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE INCREMENT (BLOCK (ALT '+=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE DECREMENT (BLOCK (ALT '-=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE SUMMATION (BLOCK (ALT '+')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE SUBTRACTION (BLOCK (ALT '-')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE MULTIPLICATION (BLOCK (ALT '*')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE DIVISION (BLOCK (ALT '/')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE MOD (BLOCK (ALT '%')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE QUESTION_MARK (BLOCK (ALT '?')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE OR (BLOCK (ALT '||')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE AND (BLOCK (ALT '&&')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE NOT (BLOCK (ALT '!')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE EQUAL (BLOCK (ALT '==')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE NOT_EQUAL (BLOCK (ALT '!=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE LESS_THAN (BLOCK (ALT '<')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE LESS_THAN_EQUAL (BLOCK (ALT '<=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN (BLOCK (ALT '>')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE ASSIGN (BLOCK (ALT '=')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE DOT (BLOCK (ALT '.')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE COMMA (BLOCK (ALT ',')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE COLON (BLOCK (ALT ':')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE SEMICOLON (BLOCK (ALT ';')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE OPEN_PARENTHESIS (BLOCK (ALT '(')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE OPEN_kEY (BLOCK (ALT '{')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE CLOSE_kEY (BLOCK (ALT '}')))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip)))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip)))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))
2023-08-23 14:13:16:512 grammar LogManager.java:25 imported rule: (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))
2023-08-23 14:13:16:512 grammar LogManager.java:25 Grammar: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p)
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 14:13:16:522 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p)
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 14:13:16:525 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p)
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-23 14:13:16:526 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftgrammLexer (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 14:13:16:546 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:16:675 left-recursion LogManager.java:25 expression returns [abstract.Expression p]
    :   ( {} oper = NOT<tokenIndex=502> expression<tokenIndex=504,p=10>{
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        } 
        | OPEN_PARENTHESIS<tokenIndex=509> expression<tokenIndex=511> CLOSE_PARENTHESIS<tokenIndex=513> 
        | NUMBER<tokenIndex=517>{
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        } 
        | FLOATT<tokenIndex=522>{
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        } 
        | STRING_LITERAL<tokenIndex=527>{
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        } 
        | CHARACTER_LITERAL<tokenIndex=532>{
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        } 
        | TRUE<tokenIndex=537>{
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | FALSE<tokenIndex=542>{
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | ID<tokenIndex=547>{
                $p = expressions.NewIdentifier($ID.text)
        } 
        | NIL<tokenIndex=552>{
                $p = expressions.NewNative(nil,symbol.NIL)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 17)}?<p=17> oper=(MULTIPLICATION<tokenIndex=376>|DIVISION<tokenIndex=378>) right=expression<tokenIndex=383,p=18>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> oper=(SUMMATION<tokenIndex=395>|SUBTRACTION<tokenIndex=397>) right=expression<tokenIndex=402,p=17>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> oper=MOD<tokenIndex=413> right=expression<tokenIndex=417,p=16>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> oper=(LESS_THAN<tokenIndex=429>|LESS_THAN_EQUAL<tokenIndex=431>) right=expression<tokenIndex=436,p=15>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> oper=(GREATER_THAN<tokenIndex=448>|GREATER_THAN_EQUAL<tokenIndex=450>) right=expression<tokenIndex=455,p=14>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> oper=(EQUAL<tokenIndex=467>|NOT_EQUAL<tokenIndex=469>) right=expression<tokenIndex=474,p=13>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> oper=(AND<tokenIndex=486>|OR<tokenIndex=488>) right=expression<tokenIndex=493,p=12>{
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  }
        )*
    ;
2023-08-23 14:13:16:683 grammar LogManager.java:25 added: (RULE expression (returns abstract.Expression p) (BLOCK (ALT (BLOCK (ALT {} (= oper (NOT (ELEMENT_OPTIONS (= tokenIndex 502)))) (expression (ELEMENT_OPTIONS (= tokenIndex 504) (= p 10))) {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT (OPEN_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 509))) (expression (ELEMENT_OPTIONS (= tokenIndex 511))) (CLOSE_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 513)))) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 517))) {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT (FLOATT (ELEMENT_OPTIONS (= tokenIndex 522))) {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT (STRING_LITERAL (ELEMENT_OPTIONS (= tokenIndex 527))) {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT (CHARACTER_LITERAL (ELEMENT_OPTIONS (= tokenIndex 532))) {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 537))) {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 542))) {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 547))) {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 552))) {
                $p = expressions.NewNative(nil,symbol.NIL)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 17)}? (ELEMENT_OPTIONS (= p 17))) (= oper (SET (MULTIPLICATION (ELEMENT_OPTIONS (= tokenIndex 376))) (DIVISION (ELEMENT_OPTIONS (= tokenIndex 378))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 383) (= p 18)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= oper (SET (SUMMATION (ELEMENT_OPTIONS (= tokenIndex 395))) (SUBTRACTION (ELEMENT_OPTIONS (= tokenIndex 397))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 402) (= p 17)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= oper (MOD (ELEMENT_OPTIONS (= tokenIndex 413)))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 417) (= p 16)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= oper (SET (LESS_THAN (ELEMENT_OPTIONS (= tokenIndex 429))) (LESS_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 431))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 436) (= p 15)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= oper (SET (GREATER_THAN (ELEMENT_OPTIONS (= tokenIndex 448))) (GREATER_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 450))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 455) (= p 14)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= oper (SET (EQUAL (ELEMENT_OPTIONS (= tokenIndex 467))) (NOT_EQUAL (ELEMENT_OPTIONS (= tokenIndex 469))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 474) (= p 13)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= oper (SET (AND (ELEMENT_OPTIONS (= tokenIndex 486))) (OR (ELEMENT_OPTIONS (= tokenIndex 488))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 493) (= p 12)))) {
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  }))))))
2023-08-23 14:13:16:686 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACTER=5, TRUE=6, FALSE=7, NIL=8, VAR=9, LET=10, PRINT=11, IF=12, ELSE=13, SWITCH=14, CASE=15, BREAK=16, DEFAULT=17, WHILE=18, FOR=19, IN=20, GUARD=21, CONTINUE=22, RETURN=23, FUNC=24, STRUCT=25, MUTATING=26, SELF=27, INOUT=28, NUMBER=29, FLOATT=30, STRING_LITERAL=31, ID=32, CHARACTER_LITERAL=33, INCREMENT=34, DECREMENT=35, SUMMATION=36, SUBTRACTION=37, MULTIPLICATION=38, DIVISION=39, MOD=40, QUESTION_MARK=41, OR=42, AND=43, NOT=44, EQUAL=45, NOT_EQUAL=46, LESS_THAN=47, LESS_THAN_EQUAL=48, GREATER_THAN=49, GREATER_THAN_EQUAL=50, ASSIGN=51, DOT=52, COMMA=53, COLON=54, SEMICOLON=55, OPEN_PARENTHESIS=56, CLOSE_PARENTHESIS=57, OPEN_kEY=58, CLOSE_kEY=59, WHITESPACE=60, COMMENT=61, LINE_COMMENT=62}
2023-08-23 14:13:16:686 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'nil'=8, 'var'=9, 'let'=10, 'print'=11, 'if'=12, 'else'=13, 'switch'=14, 'case'=15, 'break'=16, 'default'=17, 'while'=18, 'for'=19, 'in'=20, 'guard'=21, 'continue'=22, 'return'=23, 'func'=24, 'struct'=25, 'mutating'=26, 'self'=27, 'inout'=28, '+='=34, '-='=35, '+'=36, '-'=37, '*'=38, '/'=39, '%'=40, '?'=41, '||'=42, '&&'=43, '!'=44, '=='=45, '!='=46, '<'=47, '<='=48, '>'=49, '>='=50, '='=51, '.'=52, ','=53, ':'=54, ';'=55, '('=56, ')'=57, '{'=58, '}'=59}
2023-08-23 14:13:16:706 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-23 14:13:16:706 LL1 LogManager.java:25 look=[{9..12, 32}, {<EOF>, 59}]
2023-08-23 14:13:16:706 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:706 LL1 LogManager.java:25 
DECISION 1 in rule sentence
2023-08-23 14:13:16:706 LL1 LogManager.java:25 look=[9, 10, 11, 12, 32]
2023-08-23 14:13:16:706 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:706 LL1 LogManager.java:25 
DECISION 2 in rule declare_let
2023-08-23 14:13:16:706 LL1 LogManager.java:25 look=[10, 10]
2023-08-23 14:13:16:706 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:706 LL1 LogManager.java:25 
DECISION 3 in rule declare_var
2023-08-23 14:13:16:706 LL1 LogManager.java:25 look=[9, 9, 9]
2023-08-23 14:13:16:706 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:706 LL1 LogManager.java:25 
DECISION 4 in rule if_bl
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[12, 12, 12]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:707 LL1 LogManager.java:25 
DECISION 5 in rule else_if
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[13, 13, 13]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:707 LL1 LogManager.java:25 
DECISION 6 in rule expression
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[44, 56, 29, 30, 31, 33, 6, 7, 32, 8]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:707 LL1 LogManager.java:25 
DECISION 7 in rule expression
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:707 LL1 LogManager.java:25 
DECISION 8 in rule expression
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[null, null]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? false
2023-08-23 14:13:16:707 LL1 LogManager.java:25 
DECISION 9 in rule datatype
2023-08-23 14:13:16:707 LL1 LogManager.java:25 look=[1, 2, 31, 4, 33]
2023-08-23 14:13:16:707 LL1 LogManager.java:25 LL(1)? true
2023-08-23 14:13:16:708 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:16:709 action-translator LogManager.java:25 translate 
        $code = $block.blk

2023-08-23 14:13:16:711 action-translator LogManager.java:25 attr [@-1,11:14='code',<0>,12:9]
2023-08-23 14:13:16:711 action-translator LogManager.java:25 qattr [@-1,19:23='block',<0>,12:17].[@-1,25:27='blk',<0>,12:23]
2023-08-23 14:13:16:712 action-translator LogManager.java:25 translate 
        $blk = []interface{}{}
        var listInt []ISentenceContext

2023-08-23 14:13:16:712 action-translator LogManager.java:25 attr [@-1,11:13='blk',<0>,18:9]
2023-08-23 14:13:16:712 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }

2023-08-23 14:13:16:713 action-translator LogManager.java:25 attr [@-1,109:111='blk',<0>,25:17]
2023-08-23 14:13:16:713 action-translator LogManager.java:25 attr [@-1,123:125='blk',<0>,25:31]
2023-08-23 14:13:16:713 action-translator LogManager.java:25 translate $instr = $declare_var.instr
2023-08-23 14:13:16:713 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,30:23]
2023-08-23 14:13:16:713 action-translator LogManager.java:25 qattr [@-1,10:20='declare_var',<0>,30:32].[@-1,22:26='instr',<0>,30:44]
2023-08-23 14:13:16:713 action-translator LogManager.java:25 translate $instr = $declare_let.instr
2023-08-23 14:13:16:713 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,31:23]
2023-08-23 14:13:16:713 action-translator LogManager.java:25 qattr [@-1,10:20='declare_let',<0>,31:32].[@-1,22:26='instr',<0>,31:44]
2023-08-23 14:13:16:715 action-translator LogManager.java:25 translate $instr = $print_bl.instr
2023-08-23 14:13:16:715 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,32:20]
2023-08-23 14:13:16:715 action-translator LogManager.java:25 qattr [@-1,10:17='print_bl',<0>,32:29].[@-1,19:23='instr',<0>,32:38]
2023-08-23 14:13:16:715 action-translator LogManager.java:25 translate $instr = $if_bl.instr
2023-08-23 14:13:16:716 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,33:17]
2023-08-23 14:13:16:716 action-translator LogManager.java:25 qattr [@-1,10:14='if_bl',<0>,33:26].[@-1,16:20='instr',<0>,33:32]
2023-08-23 14:13:16:716 action-translator LogManager.java:25 translate $instr = $increment_bl.instr
2023-08-23 14:13:16:716 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,34:24]
2023-08-23 14:13:16:716 action-translator LogManager.java:25 qattr [@-1,10:21='increment_bl',<0>,34:33].[@-1,23:27='instr',<0>,34:46]
2023-08-23 14:13:16:717 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p)

2023-08-23 14:13:16:717 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,39:9]
2023-08-23 14:13:16:717 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,39:46].[@-1,51:54='text',<0>,39:49]
2023-08-23 14:13:16:717 action-translator LogManager.java:25 qattr [@-1,57:65='INCREMENT',<0>,39:55].[@-1,67:70='text',<0>,39:65]
2023-08-23 14:13:16:717 action-translator LogManager.java:25 qattr [@-1,73:82='expression',<0>,39:71].[@-1,84:84='p',<0>,39:82]
2023-08-23 14:13:16:719 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        
2023-08-23 14:13:16:719 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,44:17]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,44:46].[@-1,51:54='text',<0>,44:49]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 qattr [@-1,57:64='datatype',<0>,44:55].[@-1,66:67='td',<0>,44:64]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 qattr [@-1,70:79='expression',<0>,44:68].[@-1,81:81='p',<0>,44:79]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        
2023-08-23 14:13:16:720 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,47:17]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,47:46].[@-1,51:54='text',<0>,47:49]
2023-08-23 14:13:16:720 action-translator LogManager.java:25 qattr [@-1,74:83='expression',<0>,47:72].[@-1,85:85='p',<0>,47:83]
2023-08-23 14:13:16:721 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                
2023-08-23 14:13:16:722 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,54:25]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,54:67].[@-1,72:75='text',<0>,54:70]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 qattr [@-1,78:85='datatype',<0>,54:76].[@-1,87:88='td',<0>,54:85]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 qattr [@-1,91:100='expression',<0>,54:89].[@-1,102:102='p',<0>,54:100]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                
2023-08-23 14:13:16:722 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,57:25]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,57:67].[@-1,72:75='text',<0>,57:70]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 qattr [@-1,95:104='expression',<0>,57:93].[@-1,106:106='p',<0>,57:104]
2023-08-23 14:13:16:722 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                
2023-08-23 14:13:16:722 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,60:25]
2023-08-23 14:13:16:723 action-translator LogManager.java:25 qattr [@-1,72:73='ID',<0>,60:70].[@-1,75:78='text',<0>,60:73]
2023-08-23 14:13:16:723 action-translator LogManager.java:25 qattr [@-1,81:88='datatype',<0>,60:79].[@-1,90:91='td',<0>,60:88]
2023-08-23 14:13:16:723 action-translator LogManager.java:25 translate 
        $instr = instructions.NewPrint($expression.p)

2023-08-23 14:13:16:723 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,67:9]
2023-08-23 14:13:16:723 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,67:40].[@-1,53:53='p',<0>,67:51]
2023-08-23 14:13:16:724 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)

2023-08-23 14:13:16:724 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,73:9]
2023-08-23 14:13:16:724 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,73:37].[@-1,50:50='p',<0>,73:48]
2023-08-23 14:13:16:724 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,73:51].[@-1,61:63='blk',<0>,73:59]
2023-08-23 14:13:16:726 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)

2023-08-23 14:13:16:726 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,76:9]
2023-08-23 14:13:16:726 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,76:37].[@-1,50:50='p',<0>,76:48]
2023-08-23 14:13:16:726 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,76:51].[@-1,61:63='blk',<0>,76:59]
2023-08-23 14:13:16:726 action-translator LogManager.java:25 qattr [@-1,66:74='elseblock',<0>,76:64].[@-1,76:78='blk',<0>,76:74]
2023-08-23 14:13:16:727 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)

2023-08-23 14:13:16:727 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,79:9]
2023-08-23 14:13:16:727 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,79:37].[@-1,50:50='p',<0>,79:48]
2023-08-23 14:13:16:727 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,79:51].[@-1,61:63='blk',<0>,79:59]
2023-08-23 14:13:16:727 action-translator LogManager.java:25 qattr [@-1,66:72='else_if',<0>,79:64].[@-1,74:78='instr',<0>,79:72]
2023-08-23 14:13:16:728 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}

2023-08-23 14:13:16:728 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,85:9]
2023-08-23 14:13:16:728 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,85:51].[@-1,64:64='p',<0>,85:62]
2023-08-23 14:13:16:728 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,85:65].[@-1,75:77='blk',<0>,85:73]
2023-08-23 14:13:16:728 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}

2023-08-23 14:13:16:730 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,88:9]
2023-08-23 14:13:16:730 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,88:51].[@-1,64:64='p',<0>,88:62]
2023-08-23 14:13:16:730 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,88:65].[@-1,75:77='blk',<0>,88:73]
2023-08-23 14:13:16:730 action-translator LogManager.java:25 qattr [@-1,80:88='elseblock',<0>,88:78].[@-1,90:92='blk',<0>,88:88]
2023-08-23 14:13:16:730 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}

2023-08-23 14:13:16:731 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,91:9]
2023-08-23 14:13:16:731 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,91:51].[@-1,64:64='p',<0>,91:62]
2023-08-23 14:13:16:731 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,91:65].[@-1,75:77='blk',<0>,91:73]
2023-08-23 14:13:16:731 action-translator LogManager.java:25 qattr [@-1,80:86='else_if',<0>,91:78].[@-1,88:92='instr',<0>,91:86]
2023-08-23 14:13:16:732 action-translator LogManager.java:25 translate 
2023-08-23 14:13:16:733 action-translator LogManager.java:25 translate 
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        
2023-08-23 14:13:16:733 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,3:17]
2023-08-23 14:13:16:733 action-translator LogManager.java:25 qattr [@-1,59:68='expression',<0>,3:57].[@-1,70:70='p',<0>,3:68]
2023-08-23 14:13:16:733 action-translator LogManager.java:25 qattr [@-1,73:76='oper',<0>,3:71].[@-1,78:81='text',<0>,3:76]
2023-08-23 14:13:16:733 action-translator LogManager.java:25 translate 
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        
2023-08-23 14:13:16:733 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,7:43].[@-1,52:55='text',<0>,7:50]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 attr [@-1,169:169='p',<0>,11:17]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        
2023-08-23 14:13:16:734 action-translator LogManager.java:25 qattr [@-1,51:56='FLOATT',<0>,14:49].[@-1,58:61='text',<0>,14:56]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 attr [@-1,178:178='p',<0>,18:17]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 translate 
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        
2023-08-23 14:13:16:734 action-translator LogManager.java:25 qattr [@-1,28:41='STRING_LITERAL',<0>,21:26].[@-1,43:46='text',<0>,21:41]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 qattr [@-1,55:68='STRING_LITERAL',<0>,21:53].[@-1,70:73='text',<0>,21:68]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 attr [@-1,97:97='p',<0>,22:17]
2023-08-23 14:13:16:734 action-translator LogManager.java:25 translate 
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        
2023-08-23 14:13:16:736 action-translator LogManager.java:25 qattr [@-1,28:44='CHARACTER_LITERAL',<0>,25:26].[@-1,46:49='text',<0>,25:44]
2023-08-23 14:13:16:736 action-translator LogManager.java:25 qattr [@-1,58:74='CHARACTER_LITERAL',<0>,25:56].[@-1,76:79='text',<0>,25:74]
2023-08-23 14:13:16:736 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,26:17]
2023-08-23 14:13:16:736 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-23 14:13:16:736 action-translator LogManager.java:25 qattr [@-1,50:53='TRUE',<0>,29:48].[@-1,55:58='text',<0>,29:53]
2023-08-23 14:13:16:737 action-translator LogManager.java:25 attr [@-1,172:172='p',<0>,33:17]
2023-08-23 14:13:16:737 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-23 14:13:16:737 action-translator LogManager.java:25 qattr [@-1,50:54='FALSE',<0>,36:48].[@-1,56:59='text',<0>,36:54]
2023-08-23 14:13:16:738 action-translator LogManager.java:25 attr [@-1,173:173='p',<0>,40:17]
2023-08-23 14:13:16:738 action-translator LogManager.java:25 translate 
                $p = expressions.NewIdentifier($ID.text)
        
2023-08-23 14:13:16:738 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,43:17]
2023-08-23 14:13:16:738 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,43:48].[@-1,53:56='text',<0>,43:51]
2023-08-23 14:13:16:738 action-translator LogManager.java:25 translate 
                $p = expressions.NewNative(nil,symbol.NIL)
        
2023-08-23 14:13:16:738 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,46:17]
2023-08-23 14:13:16:738 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 17)
2023-08-23 14:13:16:739 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:739 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,51:27]
2023-08-23 14:13:16:739 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,51:68].[@-1,75:75='p',<0>,51:73]
2023-08-23 14:13:16:739 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,51:76].[@-1,84:84='p',<0>,51:82]
2023-08-23 14:13:16:739 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,51:85].[@-1,92:95='text',<0>,51:90]
2023-08-23 14:13:16:739 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 16)
2023-08-23 14:13:16:739 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:739 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,54:27]
2023-08-23 14:13:16:740 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,54:68].[@-1,75:75='p',<0>,54:73]
2023-08-23 14:13:16:740 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,54:76].[@-1,84:84='p',<0>,54:82]
2023-08-23 14:13:16:740 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,54:85].[@-1,92:95='text',<0>,54:90]
2023-08-23 14:13:16:740 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-23 14:13:16:740 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:740 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,57:27]
2023-08-23 14:13:16:740 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,57:68].[@-1,75:75='p',<0>,57:73]
2023-08-23 14:13:16:741 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,57:76].[@-1,84:84='p',<0>,57:82]
2023-08-23 14:13:16:741 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,57:85].[@-1,92:95='text',<0>,57:90]
2023-08-23 14:13:16:741 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-23 14:13:16:741 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:741 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,60:27]
2023-08-23 14:13:16:741 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,60:68].[@-1,75:75='p',<0>,60:73]
2023-08-23 14:13:16:741 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,60:76].[@-1,84:84='p',<0>,60:82]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,60:85].[@-1,92:95='text',<0>,60:90]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-23 14:13:16:742 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:742 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,63:27]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,63:68].[@-1,75:75='p',<0>,63:73]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,63:76].[@-1,84:84='p',<0>,63:82]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,63:85].[@-1,92:95='text',<0>,63:90]
2023-08-23 14:13:16:742 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-23 14:13:16:742 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:742 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,66:27]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,66:68].[@-1,75:75='p',<0>,66:73]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,66:76].[@-1,84:84='p',<0>,66:82]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,66:85].[@-1,92:95='text',<0>,66:90]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-23 14:13:16:744 action-translator LogManager.java:25 translate 
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 14:13:16:744 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,69:27]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,65:68='left',<0>,69:63].[@-1,70:70='p',<0>,69:68]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,73:77='right',<0>,69:71].[@-1,79:79='p',<0>,69:77]
2023-08-23 14:13:16:744 action-translator LogManager.java:25 qattr [@-1,82:85='oper',<0>,69:80].[@-1,87:90='text',<0>,69:85]
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 17)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 16)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate 
                $td = symbol.INT
        
2023-08-23 14:13:16:745 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,166:17]
2023-08-23 14:13:16:745 action-translator LogManager.java:25 translate 
                $td = symbol.FLOAT
        
2023-08-23 14:13:16:746 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,169:17]
2023-08-23 14:13:16:746 action-translator LogManager.java:25 translate 
                $td = symbol.STRING
        
2023-08-23 14:13:16:746 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,172:17]
2023-08-23 14:13:16:746 action-translator LogManager.java:25 translate 
                $td = symbol.BOOL
        
2023-08-23 14:13:16:746 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,175:17]
2023-08-23 14:13:16:746 action-translator LogManager.java:25 translate 
                $td = symbol.CHAR
        
2023-08-23 14:13:16:746 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,178:17]
2023-08-23 14:13:16:931 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:16:931 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:16:998 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:16:998 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:17:062 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:17:062 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:17:126 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 14:13:17:126 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

