2023-08-23 11:42:24:764 grammar LogManager.java:25 before: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 11:42:24:781 grammar LogManager.java:25 after: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 11:42:25:507 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (BLOCK (ALT '*') (ALT '/')) expr) (ALT expr (BLOCK (ALT '+') (ALT '-')) expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 11:42:25:507 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 11:42:25:510 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')')))))
2023-08-23 11:42:25:510 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (RULES (RULE T__0 (BLOCK (ALT '*'))) (RULE T__1 (BLOCK (ALT '/'))) (RULE T__2 (BLOCK (ALT '+'))) (RULE T__3 (BLOCK (ALT '-'))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-08-23 11:42:25:593 left-recursion LogManager.java:25 expr
    :   ( {} INT<tokenIndex=44> 
        | '('<tokenIndex=48> expr<tokenIndex=50> ')'<tokenIndex=52> 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> ('*'<tokenIndex=23>|'/'<tokenIndex=25>) expr<tokenIndex=28,p=5>
                  | {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> ('+'<tokenIndex=35>|'-'<tokenIndex=37>) expr<tokenIndex=40,p=4>
        )*
    ;
2023-08-23 11:42:25:598 grammar LogManager.java:25 added: (RULE expr (BLOCK (ALT (BLOCK (ALT {} (INT (ELEMENT_OPTIONS (= tokenIndex 44)))) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 48))) (expr (ELEMENT_OPTIONS (= tokenIndex 50))) (')' (ELEMENT_OPTIONS (= tokenIndex 52))))) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 23))) ('/' (ELEMENT_OPTIONS (= tokenIndex 25)))) (expr (ELEMENT_OPTIONS (= tokenIndex 28) (= p 5)))) (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 35))) ('-' (ELEMENT_OPTIONS (= tokenIndex 37)))) (expr (ELEMENT_OPTIONS (= tokenIndex 40) (= p 4)))))))))
2023-08-23 11:42:25:598 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, NEWLINE=7, INT=8}
2023-08-23 11:42:25:599 semantics LogManager.java:25 strings={'*'=1, '/'=2, '+'=3, '-'=4, '('=5, ')'=6}
2023-08-23 11:42:25:612 LL1 LogManager.java:25 
DECISION 0 in rule prog
2023-08-23 11:42:25:612 LL1 LogManager.java:25 look=[{5, 8}, <EOF>]
2023-08-23 11:42:25:612 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:25:612 LL1 LogManager.java:25 
DECISION 1 in rule expr
2023-08-23 11:42:25:612 LL1 LogManager.java:25 look=[8, 5]
2023-08-23 11:42:25:612 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:25:612 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-08-23 11:42:25:612 LL1 LogManager.java:25 look=[null, null]
2023-08-23 11:42:25:612 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:25:612 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-08-23 11:42:25:613 LL1 LogManager.java:25 look=[null, null]
2023-08-23 11:42:25:613 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:25:633 action-translator LogManager.java:25 translate 
2023-08-23 11:42:25:635 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-23 11:42:25:636 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-23 11:42:25:639 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-08-23 11:42:25:639 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-08-23 11:42:25:973 grammar LogManager.java:25 load Swiftlex from Swiftgramm.g4
2023-08-23 11:42:25:976 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-23 11:42:25:977 grammar LogManager.java:25 imported actions: []
2023-08-23 11:42:25:984 grammar LogManager.java:25 Swiftgramm parser:header={
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}
2023-08-23 11:42:25:984 grammar LogManager.java:25 Swiftgramm parser:init={
        $blk = []interface{}{}
        var listInt []ISentenceContext
}
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE INT (BLOCK (ALT 'Int')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE FLOAT (BLOCK (ALT 'Float')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE STRING (BLOCK (ALT 'String')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE BOOL (BLOCK (ALT 'Bool')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE CHARACTER (BLOCK (ALT 'Character')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE TRUE (BLOCK (ALT 'true')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE FALSE (BLOCK (ALT 'false')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE NIL (BLOCK (ALT 'nil')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE VAR (BLOCK (ALT 'var')))
2023-08-23 11:42:25:984 grammar LogManager.java:25 imported rule: (RULE LET (BLOCK (ALT 'let')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE PRINT (BLOCK (ALT 'print')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE IF (BLOCK (ALT 'if')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE ELSE (BLOCK (ALT 'else')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE SWITCH (BLOCK (ALT 'switch')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE CASE (BLOCK (ALT 'case')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE BREAK (BLOCK (ALT 'break')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE DEFAULT (BLOCK (ALT 'default')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE WHILE (BLOCK (ALT 'while')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE FOR (BLOCK (ALT 'for')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE IN (BLOCK (ALT 'in')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE GUARD (BLOCK (ALT 'guard')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE CONTINUE (BLOCK (ALT 'continue')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE RETURN (BLOCK (ALT 'return')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE FUNC (BLOCK (ALT 'func')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE STRUCT (BLOCK (ALT 'struct')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE MUTATING (BLOCK (ALT 'mutating')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE SELF (BLOCK (ALT 'self')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE INOUT (BLOCK (ALT 'inout')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9])))))))))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_]))))))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE SUMMATION (BLOCK (ALT '+')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE SUBTRACTION (BLOCK (ALT '-')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE MULTIPLICATION (BLOCK (ALT '*')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE DIVISION (BLOCK (ALT '/')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE MOD (BLOCK (ALT '%')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE QUESTION_MARK (BLOCK (ALT '?')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE OR (BLOCK (ALT '||')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE AND (BLOCK (ALT '&&')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE NOT (BLOCK (ALT '!')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE EQUAL (BLOCK (ALT '==')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE NOT_EQUAL (BLOCK (ALT '!=')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE LESS_THAN (BLOCK (ALT '<')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE LESS_THAN_EQUAL (BLOCK (ALT '<=')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN (BLOCK (ALT '>')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>=')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE ASSIGN (BLOCK (ALT '=')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE DOT (BLOCK (ALT '.')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE COMMA (BLOCK (ALT ',')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE COLON (BLOCK (ALT ':')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE SEMICOLON (BLOCK (ALT ';')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE OPEN_PARENTHESIS (BLOCK (ALT '(')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE OPEN_kEY (BLOCK (ALT '{')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE CLOSE_kEY (BLOCK (ALT '}')))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip)))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip)))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))
2023-08-23 11:42:25:985 grammar LogManager.java:25 imported rule: (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))
2023-08-23 11:42:25:986 grammar LogManager.java:25 Grammar: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 11:42:25:996 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 11:42:25:998 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        }))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                }))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($expression.p)
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}
}))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING_LITERAL {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER_LITERAL {
                $td = symbol.CHAR
        })))))
2023-08-23 11:42:26:000 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftgrammLexer (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ['])))) '"'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 11:42:26:021 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:153 left-recursion LogManager.java:25 expression returns [abstract.Expression p]
    :   ( {} oper = NOT<tokenIndex=479> expression<tokenIndex=481,p=10>{
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        } 
        | OPEN_PARENTHESIS<tokenIndex=486> expression<tokenIndex=488> CLOSE_PARENTHESIS<tokenIndex=490> 
        | NUMBER<tokenIndex=494>{
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        } 
        | FLOATT<tokenIndex=499>{
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        } 
        | STRING_LITERAL<tokenIndex=504>{
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        } 
        | CHARACTER_LITERAL<tokenIndex=509>{
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        } 
        | TRUE<tokenIndex=514>{
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | FALSE<tokenIndex=519>{
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        } 
        | ID<tokenIndex=524>{
                $p = expressions.NewIdentifier($ID.text)
        } 
        | NIL<tokenIndex=529>{
                $p = expressions.NewNative(nil,symbol.NIL)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 17)}?<p=17> oper=(MULTIPLICATION<tokenIndex=353>|DIVISION<tokenIndex=355>) right=expression<tokenIndex=360,p=18>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> oper=(SUMMATION<tokenIndex=372>|SUBTRACTION<tokenIndex=374>) right=expression<tokenIndex=379,p=17>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> oper=MOD<tokenIndex=390> right=expression<tokenIndex=394,p=16>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> oper=(LESS_THAN<tokenIndex=406>|LESS_THAN_EQUAL<tokenIndex=408>) right=expression<tokenIndex=413,p=15>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> oper=(GREATER_THAN<tokenIndex=425>|GREATER_THAN_EQUAL<tokenIndex=427>) right=expression<tokenIndex=432,p=14>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> oper=(EQUAL<tokenIndex=444>|NOT_EQUAL<tokenIndex=446>) right=expression<tokenIndex=451,p=13>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> oper=(AND<tokenIndex=463>|OR<tokenIndex=465>) right=expression<tokenIndex=470,p=12>{
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  }
        )*
    ;
2023-08-23 11:42:26:159 grammar LogManager.java:25 added: (RULE expression (returns abstract.Expression p) (BLOCK (ALT (BLOCK (ALT {} (= oper (NOT (ELEMENT_OPTIONS (= tokenIndex 479)))) (expression (ELEMENT_OPTIONS (= tokenIndex 481) (= p 10))) {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        }) (ALT (OPEN_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 486))) (expression (ELEMENT_OPTIONS (= tokenIndex 488))) (CLOSE_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 490)))) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 494))) {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        }) (ALT (FLOATT (ELEMENT_OPTIONS (= tokenIndex 499))) {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        }) (ALT (STRING_LITERAL (ELEMENT_OPTIONS (= tokenIndex 504))) {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        }) (ALT (CHARACTER_LITERAL (ELEMENT_OPTIONS (= tokenIndex 509))) {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 514))) {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 519))) {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 524))) {
                $p = expressions.NewIdentifier($ID.text)
        }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 529))) {
                $p = expressions.NewNative(nil,symbol.NIL)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 17)}? (ELEMENT_OPTIONS (= p 17))) (= oper (SET (MULTIPLICATION (ELEMENT_OPTIONS (= tokenIndex 353))) (DIVISION (ELEMENT_OPTIONS (= tokenIndex 355))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 360) (= p 18)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= oper (SET (SUMMATION (ELEMENT_OPTIONS (= tokenIndex 372))) (SUBTRACTION (ELEMENT_OPTIONS (= tokenIndex 374))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 379) (= p 17)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= oper (MOD (ELEMENT_OPTIONS (= tokenIndex 390)))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 394) (= p 16)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= oper (SET (LESS_THAN (ELEMENT_OPTIONS (= tokenIndex 406))) (LESS_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 408))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 413) (= p 15)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= oper (SET (GREATER_THAN (ELEMENT_OPTIONS (= tokenIndex 425))) (GREATER_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 427))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 432) (= p 14)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= oper (SET (EQUAL (ELEMENT_OPTIONS (= tokenIndex 444))) (NOT_EQUAL (ELEMENT_OPTIONS (= tokenIndex 446))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 451) (= p 13)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= oper (SET (AND (ELEMENT_OPTIONS (= tokenIndex 463))) (OR (ELEMENT_OPTIONS (= tokenIndex 465))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 470) (= p 12)))) {
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  }))))))
2023-08-23 11:42:26:161 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACTER=5, TRUE=6, FALSE=7, NIL=8, VAR=9, LET=10, PRINT=11, IF=12, ELSE=13, SWITCH=14, CASE=15, BREAK=16, DEFAULT=17, WHILE=18, FOR=19, IN=20, GUARD=21, CONTINUE=22, RETURN=23, FUNC=24, STRUCT=25, MUTATING=26, SELF=27, INOUT=28, NUMBER=29, FLOATT=30, STRING_LITERAL=31, ID=32, CHARACTER_LITERAL=33, SUMMATION=34, SUBTRACTION=35, MULTIPLICATION=36, DIVISION=37, MOD=38, QUESTION_MARK=39, OR=40, AND=41, NOT=42, EQUAL=43, NOT_EQUAL=44, LESS_THAN=45, LESS_THAN_EQUAL=46, GREATER_THAN=47, GREATER_THAN_EQUAL=48, ASSIGN=49, DOT=50, COMMA=51, COLON=52, SEMICOLON=53, OPEN_PARENTHESIS=54, CLOSE_PARENTHESIS=55, OPEN_kEY=56, CLOSE_kEY=57, WHITESPACE=58, COMMENT=59, LINE_COMMENT=60}
2023-08-23 11:42:26:161 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'nil'=8, 'var'=9, 'let'=10, 'print'=11, 'if'=12, 'else'=13, 'switch'=14, 'case'=15, 'break'=16, 'default'=17, 'while'=18, 'for'=19, 'in'=20, 'guard'=21, 'continue'=22, 'return'=23, 'func'=24, 'struct'=25, 'mutating'=26, 'self'=27, 'inout'=28, '+'=34, '-'=35, '*'=36, '/'=37, '%'=38, '?'=39, '||'=40, '&&'=41, '!'=42, '=='=43, '!='=44, '<'=45, '<='=46, '>'=47, '>='=48, '='=49, '.'=50, ','=51, ':'=52, ';'=53, '('=54, ')'=55, '{'=56, '}'=57}
2023-08-23 11:42:26:175 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-23 11:42:26:175 LL1 LogManager.java:25 look=[{9..12}, {<EOF>, 57}]
2023-08-23 11:42:26:175 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:26:175 LL1 LogManager.java:25 
DECISION 1 in rule sentence
2023-08-23 11:42:26:175 LL1 LogManager.java:25 look=[9, 10, 11, 12]
2023-08-23 11:42:26:175 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:26:175 LL1 LogManager.java:25 
DECISION 2 in rule declare_let
2023-08-23 11:42:26:175 LL1 LogManager.java:25 look=[10, 10]
2023-08-23 11:42:26:175 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:175 LL1 LogManager.java:25 
DECISION 3 in rule declare_var
2023-08-23 11:42:26:175 LL1 LogManager.java:25 look=[9, 9, 9]
2023-08-23 11:42:26:175 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:175 LL1 LogManager.java:25 
DECISION 4 in rule if_bl
2023-08-23 11:42:26:175 LL1 LogManager.java:25 look=[12, 12, 12]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:176 LL1 LogManager.java:25 
DECISION 5 in rule else_if
2023-08-23 11:42:26:176 LL1 LogManager.java:25 look=[13, 13, 13]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:176 LL1 LogManager.java:25 
DECISION 6 in rule expression
2023-08-23 11:42:26:176 LL1 LogManager.java:25 look=[42, 54, 29, 30, 31, 33, 6, 7, 32, 8]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:26:176 LL1 LogManager.java:25 
DECISION 7 in rule expression
2023-08-23 11:42:26:176 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:176 LL1 LogManager.java:25 
DECISION 8 in rule expression
2023-08-23 11:42:26:176 LL1 LogManager.java:25 look=[null, null]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? false
2023-08-23 11:42:26:176 LL1 LogManager.java:25 
DECISION 9 in rule datatype
2023-08-23 11:42:26:176 LL1 LogManager.java:25 look=[1, 2, 31, 4, 33]
2023-08-23 11:42:26:176 LL1 LogManager.java:25 LL(1)? true
2023-08-23 11:42:26:176 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:180 action-translator LogManager.java:25 translate 
        $code = $block.blk

2023-08-23 11:42:26:180 action-translator LogManager.java:25 attr [@-1,11:14='code',<0>,12:9]
2023-08-23 11:42:26:181 action-translator LogManager.java:25 qattr [@-1,19:23='block',<0>,12:17].[@-1,25:27='blk',<0>,12:23]
2023-08-23 11:42:26:182 action-translator LogManager.java:25 translate 
        $blk = []interface{}{}
        var listInt []ISentenceContext

2023-08-23 11:42:26:182 action-translator LogManager.java:25 attr [@-1,11:13='blk',<0>,18:9]
2023-08-23 11:42:26:183 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }

2023-08-23 11:42:26:183 action-translator LogManager.java:25 attr [@-1,109:111='blk',<0>,25:17]
2023-08-23 11:42:26:183 action-translator LogManager.java:25 attr [@-1,123:125='blk',<0>,25:31]
2023-08-23 11:42:26:184 action-translator LogManager.java:25 translate $instr = $declare_var.instr
2023-08-23 11:42:26:184 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,30:23]
2023-08-23 11:42:26:184 action-translator LogManager.java:25 qattr [@-1,10:20='declare_var',<0>,30:32].[@-1,22:26='instr',<0>,30:44]
2023-08-23 11:42:26:184 action-translator LogManager.java:25 translate $instr = $declare_let.instr
2023-08-23 11:42:26:184 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,31:23]
2023-08-23 11:42:26:184 action-translator LogManager.java:25 qattr [@-1,10:20='declare_let',<0>,31:32].[@-1,22:26='instr',<0>,31:44]
2023-08-23 11:42:26:185 action-translator LogManager.java:25 translate $instr = $print_bl.instr
2023-08-23 11:42:26:185 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,32:20]
2023-08-23 11:42:26:185 action-translator LogManager.java:25 qattr [@-1,10:17='print_bl',<0>,32:29].[@-1,19:23='instr',<0>,32:38]
2023-08-23 11:42:26:185 action-translator LogManager.java:25 translate $instr = $if_bl.instr
2023-08-23 11:42:26:185 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,33:17]
2023-08-23 11:42:26:186 action-translator LogManager.java:25 qattr [@-1,10:14='if_bl',<0>,33:26].[@-1,16:20='instr',<0>,33:32]
2023-08-23 11:42:26:187 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p)
        
2023-08-23 11:42:26:187 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,38:17]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,38:46].[@-1,51:54='text',<0>,38:49]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 qattr [@-1,57:64='datatype',<0>,38:55].[@-1,66:67='td',<0>,38:64]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 qattr [@-1,70:79='expression',<0>,38:68].[@-1,81:81='p',<0>,38:79]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p)
        
2023-08-23 11:42:26:188 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,41:17]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,41:46].[@-1,51:54='text',<0>,41:49]
2023-08-23 11:42:26:188 action-translator LogManager.java:25 qattr [@-1,74:83='expression',<0>,41:72].[@-1,85:85='p',<0>,41:83]
2023-08-23 11:42:26:190 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p)
                
2023-08-23 11:42:26:190 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,48:25]
2023-08-23 11:42:26:190 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,48:67].[@-1,72:75='text',<0>,48:70]
2023-08-23 11:42:26:190 action-translator LogManager.java:25 qattr [@-1,78:85='datatype',<0>,48:76].[@-1,87:88='td',<0>,48:85]
2023-08-23 11:42:26:190 action-translator LogManager.java:25 qattr [@-1,91:100='expression',<0>,48:89].[@-1,102:102='p',<0>,48:100]
2023-08-23 11:42:26:191 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p)
                
2023-08-23 11:42:26:191 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,51:25]
2023-08-23 11:42:26:191 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,51:67].[@-1,72:75='text',<0>,51:70]
2023-08-23 11:42:26:191 action-translator LogManager.java:25 qattr [@-1,95:104='expression',<0>,51:93].[@-1,106:106='p',<0>,51:104]
2023-08-23 11:42:26:191 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL))
                
2023-08-23 11:42:26:191 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,54:25]
2023-08-23 11:42:26:192 action-translator LogManager.java:25 qattr [@-1,72:73='ID',<0>,54:70].[@-1,75:78='text',<0>,54:73]
2023-08-23 11:42:26:192 action-translator LogManager.java:25 qattr [@-1,81:88='datatype',<0>,54:79].[@-1,90:91='td',<0>,54:88]
2023-08-23 11:42:26:192 action-translator LogManager.java:25 translate 
        $instr = instructions.NewPrint($expression.p)

2023-08-23 11:42:26:193 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,61:9]
2023-08-23 11:42:26:193 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,61:40].[@-1,53:53='p',<0>,61:51]
2023-08-23 11:42:26:194 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil)

2023-08-23 11:42:26:194 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,67:9]
2023-08-23 11:42:26:194 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,67:37].[@-1,50:50='p',<0>,67:48]
2023-08-23 11:42:26:194 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,67:51].[@-1,61:63='blk',<0>,67:59]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)

2023-08-23 11:42:26:195 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,70:9]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,70:37].[@-1,50:50='p',<0>,70:48]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,70:51].[@-1,61:63='blk',<0>,70:59]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 qattr [@-1,66:74='elseblock',<0>,70:64].[@-1,76:78='blk',<0>,70:74]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)

2023-08-23 11:42:26:195 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,73:9]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,73:37].[@-1,50:50='p',<0>,73:48]
2023-08-23 11:42:26:195 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,73:51].[@-1,61:63='blk',<0>,73:59]
2023-08-23 11:42:26:196 action-translator LogManager.java:25 qattr [@-1,66:72='else_if',<0>,73:64].[@-1,74:78='instr',<0>,73:72]
2023-08-23 11:42:26:196 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil)}

2023-08-23 11:42:26:196 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,79:9]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,79:51].[@-1,64:64='p',<0>,79:62]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,79:65].[@-1,75:77='blk',<0>,79:73]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk)}

2023-08-23 11:42:26:198 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,82:9]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,82:51].[@-1,64:64='p',<0>,82:62]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,82:65].[@-1,75:77='blk',<0>,82:73]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,80:88='elseblock',<0>,82:78].[@-1,90:92='blk',<0>,82:88]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr)}

2023-08-23 11:42:26:198 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,85:9]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,85:51].[@-1,64:64='p',<0>,85:62]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,85:65].[@-1,75:77='blk',<0>,85:73]
2023-08-23 11:42:26:198 action-translator LogManager.java:25 qattr [@-1,80:86='else_if',<0>,85:78].[@-1,88:92='instr',<0>,85:86]
2023-08-23 11:42:26:201 action-translator LogManager.java:25 translate 
2023-08-23 11:42:26:201 action-translator LogManager.java:25 translate 
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text)
        
2023-08-23 11:42:26:201 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,3:17]
2023-08-23 11:42:26:201 action-translator LogManager.java:25 qattr [@-1,59:68='expression',<0>,3:57].[@-1,70:70='p',<0>,3:68]
2023-08-23 11:42:26:201 action-translator LogManager.java:25 qattr [@-1,73:76='oper',<0>,3:71].[@-1,78:81='text',<0>,3:76]
2023-08-23 11:42:26:202 action-translator LogManager.java:25 translate 
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT)
        
2023-08-23 11:42:26:202 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,7:43].[@-1,52:55='text',<0>,7:50]
2023-08-23 11:42:26:202 action-translator LogManager.java:25 attr [@-1,169:169='p',<0>,11:17]
2023-08-23 11:42:26:202 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT)
        
2023-08-23 11:42:26:202 action-translator LogManager.java:25 qattr [@-1,51:56='FLOATT',<0>,14:49].[@-1,58:61='text',<0>,14:56]
2023-08-23 11:42:26:202 action-translator LogManager.java:25 attr [@-1,178:178='p',<0>,18:17]
2023-08-23 11:42:26:202 action-translator LogManager.java:25 translate 
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING)
        
2023-08-23 11:42:26:202 action-translator LogManager.java:25 qattr [@-1,28:41='STRING_LITERAL',<0>,21:26].[@-1,43:46='text',<0>,21:41]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 qattr [@-1,55:68='STRING_LITERAL',<0>,21:53].[@-1,70:73='text',<0>,21:68]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 attr [@-1,97:97='p',<0>,22:17]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 translate 
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR)
        
2023-08-23 11:42:26:203 action-translator LogManager.java:25 qattr [@-1,28:44='CHARACTER_LITERAL',<0>,25:26].[@-1,46:49='text',<0>,25:44]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 qattr [@-1,58:74='CHARACTER_LITERAL',<0>,25:56].[@-1,76:79='text',<0>,25:74]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,26:17]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-23 11:42:26:203 action-translator LogManager.java:25 qattr [@-1,50:53='TRUE',<0>,29:48].[@-1,55:58='text',<0>,29:53]
2023-08-23 11:42:26:203 action-translator LogManager.java:25 attr [@-1,172:172='p',<0>,33:17]
2023-08-23 11:42:26:204 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL) 
        
2023-08-23 11:42:26:204 action-translator LogManager.java:25 qattr [@-1,50:54='FALSE',<0>,36:48].[@-1,56:59='text',<0>,36:54]
2023-08-23 11:42:26:204 action-translator LogManager.java:25 attr [@-1,173:173='p',<0>,40:17]
2023-08-23 11:42:26:204 action-translator LogManager.java:25 translate 
                $p = expressions.NewIdentifier($ID.text)
        
2023-08-23 11:42:26:204 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,43:17]
2023-08-23 11:42:26:204 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,43:48].[@-1,53:56='text',<0>,43:51]
2023-08-23 11:42:26:204 action-translator LogManager.java:25 translate 
                $p = expressions.NewNative(nil,symbol.NIL)
        
2023-08-23 11:42:26:204 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,46:17]
2023-08-23 11:42:26:205 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 17)
2023-08-23 11:42:26:205 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:205 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,51:27]
2023-08-23 11:42:26:205 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,51:68].[@-1,75:75='p',<0>,51:73]
2023-08-23 11:42:26:205 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,51:76].[@-1,84:84='p',<0>,51:82]
2023-08-23 11:42:26:205 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,51:85].[@-1,92:95='text',<0>,51:90]
2023-08-23 11:42:26:206 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 16)
2023-08-23 11:42:26:207 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:207 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,54:27]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,54:68].[@-1,75:75='p',<0>,54:73]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,54:76].[@-1,84:84='p',<0>,54:82]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,54:85].[@-1,92:95='text',<0>,54:90]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-23 11:42:26:207 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:207 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,57:27]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,57:68].[@-1,75:75='p',<0>,57:73]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,57:76].[@-1,84:84='p',<0>,57:82]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,57:85].[@-1,92:95='text',<0>,57:90]
2023-08-23 11:42:26:207 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-23 11:42:26:208 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:208 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,60:27]
2023-08-23 11:42:26:208 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,60:68].[@-1,75:75='p',<0>,60:73]
2023-08-23 11:42:26:208 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,60:76].[@-1,84:84='p',<0>,60:82]
2023-08-23 11:42:26:208 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,60:85].[@-1,92:95='text',<0>,60:90]
2023-08-23 11:42:26:208 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-23 11:42:26:208 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:208 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,63:27]
2023-08-23 11:42:26:208 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,63:68].[@-1,75:75='p',<0>,63:73]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,63:76].[@-1,84:84='p',<0>,63:82]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,63:85].[@-1,92:95='text',<0>,63:90]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-23 11:42:26:210 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:210 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,66:27]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,66:68].[@-1,75:75='p',<0>,66:73]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,66:76].[@-1,84:84='p',<0>,66:82]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,66:85].[@-1,92:95='text',<0>,66:90]
2023-08-23 11:42:26:210 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate 
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text)
                  
2023-08-23 11:42:26:211 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,69:27]
2023-08-23 11:42:26:211 action-translator LogManager.java:25 qattr [@-1,65:68='left',<0>,69:63].[@-1,70:70='p',<0>,69:68]
2023-08-23 11:42:26:211 action-translator LogManager.java:25 qattr [@-1,73:77='right',<0>,69:71].[@-1,79:79='p',<0>,69:77]
2023-08-23 11:42:26:211 action-translator LogManager.java:25 qattr [@-1,82:85='oper',<0>,69:80].[@-1,87:90='text',<0>,69:85]
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 17)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 16)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-23 11:42:26:211 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-23 11:42:26:212 action-translator LogManager.java:25 translate 
                $td = symbol.INT
        
2023-08-23 11:42:26:212 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,160:17]
2023-08-23 11:42:26:212 action-translator LogManager.java:25 translate 
                $td = symbol.FLOAT
        
2023-08-23 11:42:26:212 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,163:17]
2023-08-23 11:42:26:212 action-translator LogManager.java:25 translate 
                $td = symbol.STRING
        
2023-08-23 11:42:26:212 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,166:17]
2023-08-23 11:42:26:212 action-translator LogManager.java:25 translate 
                $td = symbol.BOOL
        
2023-08-23 11:42:26:212 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,169:17]
2023-08-23 11:42:26:212 action-translator LogManager.java:25 translate 
                $td = symbol.CHAR
        
2023-08-23 11:42:26:212 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,172:17]
2023-08-23 11:42:26:402 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:403 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:518 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:518 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:581 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:581 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:641 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-08-23 11:42:26:641 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

