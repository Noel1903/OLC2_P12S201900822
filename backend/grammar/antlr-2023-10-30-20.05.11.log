2023-10-30 20:05:06:792 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (BLOCK (ALT '*') (ALT '/')) expr) (ALT expr (BLOCK (ALT '+') (ALT '-')) expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-10-30 20:05:06:803 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-10-30 20:05:06:828 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT expr NEWLINE)))))) (RULE expr (BLOCK (ALT expr (SET '*' '/') expr) (ALT expr (SET '+' '-') expr) (ALT INT) (ALT '(' expr ')')))))
2023-10-30 20:05:06:828 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (RULES (RULE T__0 (BLOCK (ALT '*'))) (RULE T__1 (BLOCK (ALT '/'))) (RULE T__2 (BLOCK (ALT '+'))) (RULE T__3 (BLOCK (ALT '-'))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE NEWLINE (BLOCK (ALT (+ (BLOCK (ALT [\r\n])))))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))))
2023-10-30 20:05:09:334 left-recursion LogManager.java:25 expr
    :   ( {} INT<tokenIndex=44> 
        | '('<tokenIndex=48> expr<tokenIndex=50> ')'<tokenIndex=52> 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 4)}?<p=4> ('*'<tokenIndex=23>|'/'<tokenIndex=25>) expr<tokenIndex=28,p=5>
                  | {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> ('+'<tokenIndex=35>|'-'<tokenIndex=37>) expr<tokenIndex=40,p=4>
        )*
    ;
2023-10-30 20:05:09:340 grammar LogManager.java:25 added: (RULE expr (BLOCK (ALT (BLOCK (ALT {} (INT (ELEMENT_OPTIONS (= tokenIndex 44)))) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 48))) (expr (ELEMENT_OPTIONS (= tokenIndex 50))) (')' (ELEMENT_OPTIONS (= tokenIndex 52))))) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 4)}? (ELEMENT_OPTIONS (= p 4))) (SET ('*' (ELEMENT_OPTIONS (= tokenIndex 23))) ('/' (ELEMENT_OPTIONS (= tokenIndex 25)))) (expr (ELEMENT_OPTIONS (= tokenIndex 28) (= p 5)))) (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (SET ('+' (ELEMENT_OPTIONS (= tokenIndex 35))) ('-' (ELEMENT_OPTIONS (= tokenIndex 37)))) (expr (ELEMENT_OPTIONS (= tokenIndex 40) (= p 4)))))))))
2023-10-30 20:05:09:342 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, NEWLINE=7, INT=8}
2023-10-30 20:05:09:342 semantics LogManager.java:25 strings={'*'=1, '/'=2, '+'=3, '-'=4, '('=5, ')'=6}
2023-10-30 20:05:09:362 LL1 LogManager.java:25 
DECISION 0 in rule prog
2023-10-30 20:05:09:362 LL1 LogManager.java:25 look=[{5, 8}, <EOF>]
2023-10-30 20:05:09:362 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:09:362 LL1 LogManager.java:25 
DECISION 1 in rule expr
2023-10-30 20:05:09:363 LL1 LogManager.java:25 look=[8, 5]
2023-10-30 20:05:09:363 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:09:363 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-10-30 20:05:09:363 LL1 LogManager.java:25 look=[null, null]
2023-10-30 20:05:09:363 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:09:363 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-10-30 20:05:09:363 LL1 LogManager.java:25 look=[null, null]
2023-10-30 20:05:09:363 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:09:388 action-translator LogManager.java:25 translate 
2023-10-30 20:05:09:391 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-10-30 20:05:09:392 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 20:05:09:394 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 4)
2023-10-30 20:05:09:394 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 3)
2023-10-30 20:05:09:731 grammar LogManager.java:25 load Swiftlex from Swiftgramm.g4
2023-10-30 20:05:09:734 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT assign_bl {$instr = $assign_bl.instr}) (ALT assign_vector {$instr = $assign_vector.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}) (ALT decrement_bl {$instr = $decrement_bl.instr}) (ALT while_bl {$instr = $while_bl.instr}) (ALT for_bl {$instr = $for_bl.instr}) (ALT guard_bl {$instr = $guard_bl.instr}) (ALT break_bl {$instr = $break_bl.instr}) (ALT return_bl {$instr = $return_bl.instr}) (ALT continue_bl {$instr = $continue_bl.instr}) (ALT vector_bl {$instr = $vector_bl.instr}) (ALT function_bl {$instr = $function_bl.instr}) (ALT call_function {$instr = $call_function.instr}) (ALT array_functions {$instr = $array_functions.instr}) (ALT declare_array_bl { $instr = $declare_array_bl.instr}) (ALT switch_bl {$instr = $switch_bl.instr}))) (RULE get_pos_matrix (returns []interface{} p) (BLOCK (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET get_pos_matrix {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = append([]interface{}{exp},$get_pos_matrix.p...)
}) (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = []interface{}{exp}
}))) (RULE switch_bl (returns abstract.Instruction instr) (BLOCK (ALT SWITCH expression OPEN_kEY cases CLOSE_kEY {
        $instr = instructions.NewSwitch($expression.p,$cases.p,$SWITCH.line,$SWITCH.pos)
}))) (RULE cases (returns []interface{} p) (BLOCK (ALT CASE expression COLON block cases {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = append([]interface{}{value},$cases.p...)
}) (ALT CASE expression COLON block {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = []interface{}{value}
}) (ALT DEFAULT COLON block {
        value := instructions.NewCaseSwitch(nil,$block.blk,$DEFAULT.line,$DEFAULT.pos)
        $p = []interface{}{value}       
}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE decrement_bl (returns abstract.Instruction instr) (BLOCK (ALT ID DECREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$DECREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE break_bl (returns abstract.Instruction instr) (BLOCK (ALT BREAK {
        $instr = instructions.NewBreak("break")
}))) (RULE return_bl (returns abstract.Instruction instr) (BLOCK (ALT RETURN expression {
        $instr = instructions.NewReturn($expression.p)
}) (ALT RETURN {
        $instr = instructions.NewReturn(expressions.NewNative(nil,symbol.NIL,$RETURN.line,$RETURN.pos))
}))) (RULE continue_bl (returns abstract.Instruction instr) (BLOCK (ALT CONTINUE {
        $instr = instructions.NewContinue("continue")
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
        }))) (RULE native_function (returns abstract.Expression p) (BLOCK (ALT STRING OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($STRING.text,$expression.p)
}) (ALT INT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($INT.text,$expression.p)
}) (ALT FLOAT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($FLOAT.text,$expression.p)
}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$QUESTION_MARK.line,$QUESTION_MARK.pos),$ID.line,$ID.pos)
                }))) (RULE assign_bl (returns abstract.Instruction instr) (BLOCK (ALT ID ASSIGN expression {
        $instr = instructions.NewAsignVariable($ID.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS list_print CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($list_print.p)
}))) (RULE list_print (returns []interface{} p) (BLOCK (ALT expression COMMA list_print {
        $p = append([]interface{}{$expression.p},$list_print.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$IF.line,$IF.pos)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$ELSE.line,$ELSE.pos)}
}))) (RULE while_bl (returns abstract.Instruction instr) (BLOCK (ALT WHILE expression OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewWhile($expression.p,$block.blk,$WHILE.line,$WHILE.pos)
}))) (RULE for_bl (returns abstract.Instruction instr) (BLOCK (ALT FOR ID IN (= expression1 expression) RANGE (= expression2 expression) OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewFor($ID.text,$expression1.p,$expression2.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE guard_bl (returns abstract.Instruction instr) (BLOCK (ALT GUARD expression ELSE OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewGuard($expression.p,$block.blk,$GUARD.line,$GUARD.pos)
}))) (RULE vector_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET array_exp CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,$array_exp.p,$ID.line,$ID.pos)
}) (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos)
}))) (RULE array_exp (returns []interface{} p) (BLOCK (ALT expression COMMA array_exp {
        $p = append([]interface{}{$expression.p},$array_exp.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
        
}))) (RULE array_functions (returns abstract.Instruction instr) (BLOCK (ALT ID DOT APPEND OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$APPEND.text,$expression.p,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVELAST OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVELAST.text,nil,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVE OPEN_PARENTHESIS AT COLON expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVE.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE assign_vector (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_BRACKET expression CLOSE_BRACKET ASSIGN expression {
        $instr = instructions.NewAsignVector($ID.text,$expression.p,$expression.p,$ID.line,$ID.pos)
}))) (RULE function_bl (returns abstract.Instruction instr) (BLOCK (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,$params.p,$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        //fmt.Println($params.p)
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,$params.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE params (returns []interface{} p) (BLOCK (ALT ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}))) (RULE extern_params (returns string p) (BLOCK (ALT ID {
        $p = $ID.text
}) (ALT UNDERSCORE {
        $p = $UNDERSCORE.text
}))) (RULE call_function (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,[]interface{}{},$ID.line,$ID.pos)
}) (ALT ID OPEN_PARENTHESIS list_exp CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,$list_exp.p,$ID.line,$ID.pos)
}))) (RULE list_exp (returns []interface{} p) (BLOCK (ALT expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,"_")
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT expression {
        value := instructions.NewParamCall($expression.p,"_")
        $p = []interface{}{value}
}) (ALT ID COLON expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT ID COLON expression {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = []interface{}{value}
}))) (RULE call_function_exp (returns abstract.Expression p) (BLOCK (ALT call_function {
        $p = expressions.NewCallFunctionExp($call_function.instr)
}))) (RULE declare_array_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON type_matrix ASSIGN OPEN_BRACKET exp_matriz CLOSE_BRACKET {
        $instr = instructions.NewDeclareArray($ID.text,$type_matrix.td,$exp_matriz.p)
}))) (RULE exp_matriz (returns []interface{} p) (BLOCK (ALT expression {
        value := $expression.p
        $p = []interface{}{value}
}) (ALT expression COMMA exp_matriz { 
        value := $expression.p
        $p = append([]interface{}{value},$exp_matriz.p...)
}))) (RULE type_matrix (returns symbol.TypeData td) (BLOCK (ALT OPEN_BRACKET type_matrix CLOSE_BRACKET {
        $td = $type_matrix.td
}) (ALT OPEN_BRACKET datatype CLOSE_BRACKET {
        $td = $datatype.td
}))) (RULE definition_matrix (returns [][]interface{} p) (BLOCK (ALT type_matrix))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper '-') expression {
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
                $p = $expression.p
        }) (ALT call_function_exp {
                $p = $call_function_exp.p
        }) (ALT native_function {
                $p = $native_function.p
        }) (ALT ID get_pos_matrix {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        }) (ALT ID OPEN_BRACKET expression CLOSE_BRACKET {
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        }) (ALT ID DOT COUNT {
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        }) (ALT ID DOT ISEMPTY {
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        }) (ALT OPEN_BRACKET array_exp CLOSE_BRACKET {
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        }) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER {
                $td = symbol.CHAR
        })))))
2023-10-30 20:05:09:738 grammar LogManager.java:25 imported actions: []
2023-10-30 20:05:09:747 grammar LogManager.java:25 Swiftgramm parser:header={
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}
2023-10-30 20:05:09:747 grammar LogManager.java:25 Swiftgramm parser:init={
        $blk = []interface{}{}
        var listInt []ISentenceContext
}
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE INT (BLOCK (ALT 'Int')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE FLOAT (BLOCK (ALT 'Float')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE STRING (BLOCK (ALT 'String')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE BOOL (BLOCK (ALT 'Bool')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE CHARACTER (BLOCK (ALT 'Character')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE TRUE (BLOCK (ALT 'true')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE FALSE (BLOCK (ALT 'false')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE NIL (BLOCK (ALT 'nil')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE VAR (BLOCK (ALT 'var')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE LET (BLOCK (ALT 'let')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE PRINT (BLOCK (ALT 'print')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE IF (BLOCK (ALT 'if')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE ELSE (BLOCK (ALT 'else')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE SWITCH (BLOCK (ALT 'switch')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE CASE (BLOCK (ALT 'case')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE BREAK (BLOCK (ALT 'break')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE DEFAULT (BLOCK (ALT 'default')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE WHILE (BLOCK (ALT 'while')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE FOR (BLOCK (ALT 'for')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE IN (BLOCK (ALT 'in')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE GUARD (BLOCK (ALT 'guard')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE CONTINUE (BLOCK (ALT 'continue')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE RETURN (BLOCK (ALT 'return')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE FUNC (BLOCK (ALT 'func')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE STRUCT (BLOCK (ALT 'struct')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE MUTATING (BLOCK (ALT 'mutating')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE SELF (BLOCK (ALT 'self')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE INOUT (BLOCK (ALT 'inout')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE APPEND (BLOCK (ALT 'append')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE REMOVELAST (BLOCK (ALT 'removeLast')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE REMOVE (BLOCK (ALT 'remove')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE AT (BLOCK (ALT 'at')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE ISEMPTY (BLOCK (ALT 'IsEmpty')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE COUNT (BLOCK (ALT 'count')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))))))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9])))))))))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_]))))))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE INCREMENT (BLOCK (ALT '+=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE DECREMENT (BLOCK (ALT '-=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE RANGE (BLOCK (ALT '...')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE SUMMATION (BLOCK (ALT '+')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE SUBTRACTION (BLOCK (ALT '-')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE MULTIPLICATION (BLOCK (ALT '*')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE DIVISION (BLOCK (ALT '/')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE MOD (BLOCK (ALT '%')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE QUESTION_MARK (BLOCK (ALT '?')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE OR (BLOCK (ALT '||')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE AND (BLOCK (ALT '&&')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE NOT (BLOCK (ALT '!')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE EQUAL (BLOCK (ALT '==')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE NOT_EQUAL (BLOCK (ALT '!=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE LESS_THAN (BLOCK (ALT '<')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE LESS_THAN_EQUAL (BLOCK (ALT '<=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN (BLOCK (ALT '>')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE ASSIGN (BLOCK (ALT '=')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE DOT (BLOCK (ALT '.')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE COMMA (BLOCK (ALT ',')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE COLON (BLOCK (ALT ':')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE SEMICOLON (BLOCK (ALT ';')))
2023-10-30 20:05:09:747 grammar LogManager.java:25 imported rule: (RULE OPEN_PARENTHESIS (BLOCK (ALT '(')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE OPEN_kEY (BLOCK (ALT '{')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE CLOSE_kEY (BLOCK (ALT '}')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE OPEN_BRACKET (BLOCK (ALT '[')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE CLOSE_BRACKET (BLOCK (ALT ']')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE ARROW (BLOCK (ALT '->')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE UNDERSCORE (BLOCK (ALT '_')))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip)))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip)))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))
2023-10-30 20:05:09:748 grammar LogManager.java:25 imported rule: (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))
2023-10-30 20:05:09:748 grammar LogManager.java:25 Grammar: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT assign_bl {$instr = $assign_bl.instr}) (ALT assign_vector {$instr = $assign_vector.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}) (ALT decrement_bl {$instr = $decrement_bl.instr}) (ALT while_bl {$instr = $while_bl.instr}) (ALT for_bl {$instr = $for_bl.instr}) (ALT guard_bl {$instr = $guard_bl.instr}) (ALT break_bl {$instr = $break_bl.instr}) (ALT return_bl {$instr = $return_bl.instr}) (ALT continue_bl {$instr = $continue_bl.instr}) (ALT vector_bl {$instr = $vector_bl.instr}) (ALT function_bl {$instr = $function_bl.instr}) (ALT call_function {$instr = $call_function.instr}) (ALT array_functions {$instr = $array_functions.instr}) (ALT declare_array_bl { $instr = $declare_array_bl.instr}) (ALT switch_bl {$instr = $switch_bl.instr}))) (RULE get_pos_matrix (returns []interface{} p) (BLOCK (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET get_pos_matrix {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = append([]interface{}{exp},$get_pos_matrix.p...)
}) (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = []interface{}{exp}
}))) (RULE switch_bl (returns abstract.Instruction instr) (BLOCK (ALT SWITCH expression OPEN_kEY cases CLOSE_kEY {
        $instr = instructions.NewSwitch($expression.p,$cases.p,$SWITCH.line,$SWITCH.pos)
}))) (RULE cases (returns []interface{} p) (BLOCK (ALT CASE expression COLON block cases {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = append([]interface{}{value},$cases.p...)
}) (ALT CASE expression COLON block {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = []interface{}{value}
}) (ALT DEFAULT COLON block {
        value := instructions.NewCaseSwitch(nil,$block.blk,$DEFAULT.line,$DEFAULT.pos)
        $p = []interface{}{value}       
}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE decrement_bl (returns abstract.Instruction instr) (BLOCK (ALT ID DECREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$DECREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE break_bl (returns abstract.Instruction instr) (BLOCK (ALT BREAK {
        $instr = instructions.NewBreak("break")
}))) (RULE return_bl (returns abstract.Instruction instr) (BLOCK (ALT RETURN expression {
        $instr = instructions.NewReturn($expression.p)
}) (ALT RETURN {
        $instr = instructions.NewReturn(expressions.NewNative(nil,symbol.NIL,$RETURN.line,$RETURN.pos))
}))) (RULE continue_bl (returns abstract.Instruction instr) (BLOCK (ALT CONTINUE {
        $instr = instructions.NewContinue("continue")
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
        }))) (RULE native_function (returns abstract.Expression p) (BLOCK (ALT STRING OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($STRING.text,$expression.p)
}) (ALT INT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($INT.text,$expression.p)
}) (ALT FLOAT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($FLOAT.text,$expression.p)
}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$QUESTION_MARK.line,$QUESTION_MARK.pos),$ID.line,$ID.pos)
                }))) (RULE assign_bl (returns abstract.Instruction instr) (BLOCK (ALT ID ASSIGN expression {
        $instr = instructions.NewAsignVariable($ID.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS list_print CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($list_print.p)
}))) (RULE list_print (returns []interface{} p) (BLOCK (ALT expression COMMA list_print {
        $p = append([]interface{}{$expression.p},$list_print.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$IF.line,$IF.pos)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$ELSE.line,$ELSE.pos)}
}))) (RULE while_bl (returns abstract.Instruction instr) (BLOCK (ALT WHILE expression OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewWhile($expression.p,$block.blk,$WHILE.line,$WHILE.pos)
}))) (RULE for_bl (returns abstract.Instruction instr) (BLOCK (ALT FOR ID IN (= expression1 expression) RANGE (= expression2 expression) OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewFor($ID.text,$expression1.p,$expression2.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE guard_bl (returns abstract.Instruction instr) (BLOCK (ALT GUARD expression ELSE OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewGuard($expression.p,$block.blk,$GUARD.line,$GUARD.pos)
}))) (RULE vector_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET array_exp CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,$array_exp.p,$ID.line,$ID.pos)
}) (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos)
}))) (RULE array_exp (returns []interface{} p) (BLOCK (ALT expression COMMA array_exp {
        $p = append([]interface{}{$expression.p},$array_exp.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
        
}))) (RULE array_functions (returns abstract.Instruction instr) (BLOCK (ALT ID DOT APPEND OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$APPEND.text,$expression.p,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVELAST OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVELAST.text,nil,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVE OPEN_PARENTHESIS AT COLON expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVE.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE assign_vector (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_BRACKET expression CLOSE_BRACKET ASSIGN expression {
        $instr = instructions.NewAsignVector($ID.text,$expression.p,$expression.p,$ID.line,$ID.pos)
}))) (RULE function_bl (returns abstract.Instruction instr) (BLOCK (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,$params.p,$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        //fmt.Println($params.p)
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,$params.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE params (returns []interface{} p) (BLOCK (ALT ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}))) (RULE extern_params (returns string p) (BLOCK (ALT ID {
        $p = $ID.text
}) (ALT UNDERSCORE {
        $p = $UNDERSCORE.text
}))) (RULE call_function (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,[]interface{}{},$ID.line,$ID.pos)
}) (ALT ID OPEN_PARENTHESIS list_exp CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,$list_exp.p,$ID.line,$ID.pos)
}))) (RULE list_exp (returns []interface{} p) (BLOCK (ALT expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,"_")
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT expression {
        value := instructions.NewParamCall($expression.p,"_")
        $p = []interface{}{value}
}) (ALT ID COLON expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT ID COLON expression {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = []interface{}{value}
}))) (RULE call_function_exp (returns abstract.Expression p) (BLOCK (ALT call_function {
        $p = expressions.NewCallFunctionExp($call_function.instr)
}))) (RULE declare_array_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON type_matrix ASSIGN OPEN_BRACKET exp_matriz CLOSE_BRACKET {
        $instr = instructions.NewDeclareArray($ID.text,$type_matrix.td,$exp_matriz.p)
}))) (RULE exp_matriz (returns []interface{} p) (BLOCK (ALT expression {
        value := $expression.p
        $p = []interface{}{value}
}) (ALT expression COMMA exp_matriz { 
        value := $expression.p
        $p = append([]interface{}{value},$exp_matriz.p...)
}))) (RULE type_matrix (returns symbol.TypeData td) (BLOCK (ALT OPEN_BRACKET type_matrix CLOSE_BRACKET {
        $td = $type_matrix.td
}) (ALT OPEN_BRACKET datatype CLOSE_BRACKET {
        $td = $datatype.td
}))) (RULE definition_matrix (returns [][]interface{} p) (BLOCK (ALT type_matrix))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (BLOCK (ALT MULTIPLICATION) (ALT DIVISION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT SUMMATION) (ALT SUBTRACTION))) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT LESS_THAN) (ALT LESS_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT GREATER_THAN) (ALT GREATER_THAN_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT EQUAL) (ALT NOT_EQUAL))) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (BLOCK (ALT AND) (ALT OR))) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper '-') expression {
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
                $p = $expression.p
        }) (ALT call_function_exp {
                $p = $call_function_exp.p
        }) (ALT native_function {
                $p = $native_function.p
        }) (ALT ID get_pos_matrix {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        }) (ALT ID OPEN_BRACKET expression CLOSE_BRACKET {
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        }) (ALT ID DOT COUNT {
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        }) (ALT ID DOT ISEMPTY {
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        }) (ALT OPEN_BRACKET array_exp CLOSE_BRACKET {
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        }) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"'))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE RANGE (BLOCK (ALT '...'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE OPEN_BRACKET (BLOCK (ALT '['))) (RULE CLOSE_BRACKET (BLOCK (ALT ']'))) (RULE ARROW (BLOCK (ALT '->'))) (RULE UNDERSCORE (BLOCK (ALT '_'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-10-30 20:05:09:769 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT assign_bl {$instr = $assign_bl.instr}) (ALT assign_vector {$instr = $assign_vector.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}) (ALT decrement_bl {$instr = $decrement_bl.instr}) (ALT while_bl {$instr = $while_bl.instr}) (ALT for_bl {$instr = $for_bl.instr}) (ALT guard_bl {$instr = $guard_bl.instr}) (ALT break_bl {$instr = $break_bl.instr}) (ALT return_bl {$instr = $return_bl.instr}) (ALT continue_bl {$instr = $continue_bl.instr}) (ALT vector_bl {$instr = $vector_bl.instr}) (ALT function_bl {$instr = $function_bl.instr}) (ALT call_function {$instr = $call_function.instr}) (ALT array_functions {$instr = $array_functions.instr}) (ALT declare_array_bl { $instr = $declare_array_bl.instr}) (ALT switch_bl {$instr = $switch_bl.instr}))) (RULE get_pos_matrix (returns []interface{} p) (BLOCK (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET get_pos_matrix {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = append([]interface{}{exp},$get_pos_matrix.p...)
}) (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = []interface{}{exp}
}))) (RULE switch_bl (returns abstract.Instruction instr) (BLOCK (ALT SWITCH expression OPEN_kEY cases CLOSE_kEY {
        $instr = instructions.NewSwitch($expression.p,$cases.p,$SWITCH.line,$SWITCH.pos)
}))) (RULE cases (returns []interface{} p) (BLOCK (ALT CASE expression COLON block cases {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = append([]interface{}{value},$cases.p...)
}) (ALT CASE expression COLON block {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = []interface{}{value}
}) (ALT DEFAULT COLON block {
        value := instructions.NewCaseSwitch(nil,$block.blk,$DEFAULT.line,$DEFAULT.pos)
        $p = []interface{}{value}       
}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE decrement_bl (returns abstract.Instruction instr) (BLOCK (ALT ID DECREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$DECREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE break_bl (returns abstract.Instruction instr) (BLOCK (ALT BREAK {
        $instr = instructions.NewBreak("break")
}))) (RULE return_bl (returns abstract.Instruction instr) (BLOCK (ALT RETURN expression {
        $instr = instructions.NewReturn($expression.p)
}) (ALT RETURN {
        $instr = instructions.NewReturn(expressions.NewNative(nil,symbol.NIL,$RETURN.line,$RETURN.pos))
}))) (RULE continue_bl (returns abstract.Instruction instr) (BLOCK (ALT CONTINUE {
        $instr = instructions.NewContinue("continue")
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
        }))) (RULE native_function (returns abstract.Expression p) (BLOCK (ALT STRING OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($STRING.text,$expression.p)
}) (ALT INT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($INT.text,$expression.p)
}) (ALT FLOAT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($FLOAT.text,$expression.p)
}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$QUESTION_MARK.line,$QUESTION_MARK.pos),$ID.line,$ID.pos)
                }))) (RULE assign_bl (returns abstract.Instruction instr) (BLOCK (ALT ID ASSIGN expression {
        $instr = instructions.NewAsignVariable($ID.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS list_print CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($list_print.p)
}))) (RULE list_print (returns []interface{} p) (BLOCK (ALT expression COMMA list_print {
        $p = append([]interface{}{$expression.p},$list_print.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$IF.line,$IF.pos)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$ELSE.line,$ELSE.pos)}
}))) (RULE while_bl (returns abstract.Instruction instr) (BLOCK (ALT WHILE expression OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewWhile($expression.p,$block.blk,$WHILE.line,$WHILE.pos)
}))) (RULE for_bl (returns abstract.Instruction instr) (BLOCK (ALT FOR ID IN (= expression1 expression) RANGE (= expression2 expression) OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewFor($ID.text,$expression1.p,$expression2.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE guard_bl (returns abstract.Instruction instr) (BLOCK (ALT GUARD expression ELSE OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewGuard($expression.p,$block.blk,$GUARD.line,$GUARD.pos)
}))) (RULE vector_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET array_exp CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,$array_exp.p,$ID.line,$ID.pos)
}) (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos)
}))) (RULE array_exp (returns []interface{} p) (BLOCK (ALT expression COMMA array_exp {
        $p = append([]interface{}{$expression.p},$array_exp.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
        
}))) (RULE array_functions (returns abstract.Instruction instr) (BLOCK (ALT ID DOT APPEND OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$APPEND.text,$expression.p,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVELAST OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVELAST.text,nil,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVE OPEN_PARENTHESIS AT COLON expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVE.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE assign_vector (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_BRACKET expression CLOSE_BRACKET ASSIGN expression {
        $instr = instructions.NewAsignVector($ID.text,$expression.p,$expression.p,$ID.line,$ID.pos)
}))) (RULE function_bl (returns abstract.Instruction instr) (BLOCK (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,$params.p,$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        //fmt.Println($params.p)
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,$params.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE params (returns []interface{} p) (BLOCK (ALT ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}))) (RULE extern_params (returns string p) (BLOCK (ALT ID {
        $p = $ID.text
}) (ALT UNDERSCORE {
        $p = $UNDERSCORE.text
}))) (RULE call_function (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,[]interface{}{},$ID.line,$ID.pos)
}) (ALT ID OPEN_PARENTHESIS list_exp CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,$list_exp.p,$ID.line,$ID.pos)
}))) (RULE list_exp (returns []interface{} p) (BLOCK (ALT expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,"_")
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT expression {
        value := instructions.NewParamCall($expression.p,"_")
        $p = []interface{}{value}
}) (ALT ID COLON expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT ID COLON expression {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = []interface{}{value}
}))) (RULE call_function_exp (returns abstract.Expression p) (BLOCK (ALT call_function {
        $p = expressions.NewCallFunctionExp($call_function.instr)
}))) (RULE declare_array_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON type_matrix ASSIGN OPEN_BRACKET exp_matriz CLOSE_BRACKET {
        $instr = instructions.NewDeclareArray($ID.text,$type_matrix.td,$exp_matriz.p)
}))) (RULE exp_matriz (returns []interface{} p) (BLOCK (ALT expression {
        value := $expression.p
        $p = []interface{}{value}
}) (ALT expression COMMA exp_matriz { 
        value := $expression.p
        $p = append([]interface{}{value},$exp_matriz.p...)
}))) (RULE type_matrix (returns symbol.TypeData td) (BLOCK (ALT OPEN_BRACKET type_matrix CLOSE_BRACKET {
        $td = $type_matrix.td
}) (ALT OPEN_BRACKET datatype CLOSE_BRACKET {
        $td = $datatype.td
}))) (RULE definition_matrix (returns [][]interface{} p) (BLOCK (ALT type_matrix))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper '-') expression {
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
                $p = $expression.p
        }) (ALT call_function_exp {
                $p = $call_function_exp.p
        }) (ALT native_function {
                $p = $native_function.p
        }) (ALT ID get_pos_matrix {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        }) (ALT ID OPEN_BRACKET expression CLOSE_BRACKET {
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        }) (ALT ID DOT COUNT {
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        }) (ALT ID DOT ISEMPTY {
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        }) (ALT OPEN_BRACKET array_exp CLOSE_BRACKET {
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        }) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER {
                $td = symbol.CHAR
        }))) (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"'))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE RANGE (BLOCK (ALT '...'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE OPEN_BRACKET (BLOCK (ALT '['))) (RULE CLOSE_BRACKET (BLOCK (ALT ']'))) (RULE ARROW (BLOCK (ALT '->'))) (RULE UNDERSCORE (BLOCK (ALT '_'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-10-30 20:05:09:777 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Swiftgramm (import Swiftlex) (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {
        $code = $block.blk
}))) (RULE block (returns []interface{} blk) (@ init {
        $blk = []interface{}{}
        var listInt []ISentenceContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= instr sentence)))) {
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }
}))) (RULE sentence (returns abstract.Instruction instr) (BLOCK (ALT declare_var {$instr = $declare_var.instr}) (ALT declare_let {$instr = $declare_let.instr}) (ALT assign_bl {$instr = $assign_bl.instr}) (ALT assign_vector {$instr = $assign_vector.instr}) (ALT print_bl {$instr = $print_bl.instr}) (ALT if_bl {$instr = $if_bl.instr}) (ALT increment_bl {$instr = $increment_bl.instr}) (ALT decrement_bl {$instr = $decrement_bl.instr}) (ALT while_bl {$instr = $while_bl.instr}) (ALT for_bl {$instr = $for_bl.instr}) (ALT guard_bl {$instr = $guard_bl.instr}) (ALT break_bl {$instr = $break_bl.instr}) (ALT return_bl {$instr = $return_bl.instr}) (ALT continue_bl {$instr = $continue_bl.instr}) (ALT vector_bl {$instr = $vector_bl.instr}) (ALT function_bl {$instr = $function_bl.instr}) (ALT call_function {$instr = $call_function.instr}) (ALT array_functions {$instr = $array_functions.instr}) (ALT declare_array_bl { $instr = $declare_array_bl.instr}) (ALT switch_bl {$instr = $switch_bl.instr}))) (RULE get_pos_matrix (returns []interface{} p) (BLOCK (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET get_pos_matrix {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = append([]interface{}{exp},$get_pos_matrix.p...)
}) (ALT OPEN_BRACKET NUMBER CLOSE_BRACKET {
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = []interface{}{exp}
}))) (RULE switch_bl (returns abstract.Instruction instr) (BLOCK (ALT SWITCH expression OPEN_kEY cases CLOSE_kEY {
        $instr = instructions.NewSwitch($expression.p,$cases.p,$SWITCH.line,$SWITCH.pos)
}))) (RULE cases (returns []interface{} p) (BLOCK (ALT CASE expression COLON block cases {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = append([]interface{}{value},$cases.p...)
}) (ALT CASE expression COLON block {
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = []interface{}{value}
}) (ALT DEFAULT COLON block {
        value := instructions.NewCaseSwitch(nil,$block.blk,$DEFAULT.line,$DEFAULT.pos)
        $p = []interface{}{value}       
}))) (RULE increment_bl (returns abstract.Instruction instr) (BLOCK (ALT ID INCREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE decrement_bl (returns abstract.Instruction instr) (BLOCK (ALT ID DECREMENT expression {
        $instr = instructions.NewIncreDecrem($ID.text,$DECREMENT.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE break_bl (returns abstract.Instruction instr) (BLOCK (ALT BREAK {
        $instr = instructions.NewBreak("break")
}))) (RULE return_bl (returns abstract.Instruction instr) (BLOCK (ALT RETURN expression {
        $instr = instructions.NewReturn($expression.p)
}) (ALT RETURN {
        $instr = instructions.NewReturn(expressions.NewNative(nil,symbol.NIL,$RETURN.line,$RETURN.pos))
}))) (RULE continue_bl (returns abstract.Instruction instr) (BLOCK (ALT CONTINUE {
        $instr = instructions.NewContinue("continue")
}))) (RULE declare_let (returns abstract.Instruction instr) (BLOCK (ALT LET ID COLON datatype ASSIGN expression {
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
        }) (ALT LET ID ASSIGN expression {
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
        }))) (RULE native_function (returns abstract.Expression p) (BLOCK (ALT STRING OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($STRING.text,$expression.p)
}) (ALT INT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($INT.text,$expression.p)
}) (ALT FLOAT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $p = expressions.NewNativeFunction($FLOAT.text,$expression.p)
}))) (RULE declare_var (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON datatype ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID ASSIGN expression {
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
                }) (ALT VAR ID COLON datatype QUESTION_MARK {
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$QUESTION_MARK.line,$QUESTION_MARK.pos),$ID.line,$ID.pos)
                }))) (RULE assign_bl (returns abstract.Instruction instr) (BLOCK (ALT ID ASSIGN expression {
        $instr = instructions.NewAsignVariable($ID.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE print_bl (returns abstract.Instruction instr) (BLOCK (ALT PRINT OPEN_PARENTHESIS list_print CLOSE_PARENTHESIS {
        $instr = instructions.NewPrint($list_print.p)
}))) (RULE list_print (returns []interface{} p) (BLOCK (ALT expression COMMA list_print {
        $p = append([]interface{}{$expression.p},$list_print.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
}))) (RULE if_bl (returns abstract.Instruction instr) (BLOCK (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$IF.line,$IF.pos)
}) (ALT IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$IF.line,$IF.pos)
}))) (RULE else_if (returns []interface{} instr) (BLOCK (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY ELSE OPEN_kEY (= elseblock block) CLOSE_kEY {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$ELSE.line,$ELSE.pos)}
}) (ALT ELSE IF expression OPEN_kEY (= ifblock block) CLOSE_kEY else_if {
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$ELSE.line,$ELSE.pos)}
}))) (RULE while_bl (returns abstract.Instruction instr) (BLOCK (ALT WHILE expression OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewWhile($expression.p,$block.blk,$WHILE.line,$WHILE.pos)
}))) (RULE for_bl (returns abstract.Instruction instr) (BLOCK (ALT FOR ID IN (= expression1 expression) RANGE (= expression2 expression) OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewFor($ID.text,$expression1.p,$expression2.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE guard_bl (returns abstract.Instruction instr) (BLOCK (ALT GUARD expression ELSE OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewGuard($expression.p,$block.blk,$GUARD.line,$GUARD.pos)
}))) (RULE vector_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET array_exp CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,$array_exp.p,$ID.line,$ID.pos)
}) (ALT VAR ID COLON OPEN_BRACKET datatype CLOSE_BRACKET ASSIGN OPEN_BRACKET CLOSE_BRACKET {
        
        $instr = instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos)
}))) (RULE array_exp (returns []interface{} p) (BLOCK (ALT expression COMMA array_exp {
        $p = append([]interface{}{$expression.p},$array_exp.p...)
}) (ALT expression {
        $p = []interface{}{$expression.p}
        
}))) (RULE array_functions (returns abstract.Instruction instr) (BLOCK (ALT ID DOT APPEND OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$APPEND.text,$expression.p,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVELAST OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVELAST.text,nil,$ID.line,$ID.pos)
}) (ALT ID DOT REMOVE OPEN_PARENTHESIS AT COLON expression CLOSE_PARENTHESIS {
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVE.text,$expression.p,$ID.line,$ID.pos)
}))) (RULE assign_vector (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_BRACKET expression CLOSE_BRACKET ASSIGN expression {
        $instr = instructions.NewAsignVector($ID.text,$expression.p,$expression.p,$ID.line,$ID.pos)
}))) (RULE function_bl (returns abstract.Instruction instr) (BLOCK (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,[]interface{}{},$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS ARROW datatype OPEN_kEY block CLOSE_kEY {
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,$params.p,$block.blk,$ID.line,$ID.pos)
}) (ALT FUNC ID OPEN_PARENTHESIS params CLOSE_PARENTHESIS OPEN_kEY block CLOSE_kEY {
        //fmt.Println($params.p)
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,$params.p,$block.blk,$ID.line,$ID.pos)
}))) (RULE params (returns []interface{} p) (BLOCK (ALT ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON datatype COMMA params {
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON datatype {
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}
}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET COMMA params {
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)

}) (ALT extern_params ID COLON OPEN_BRACKET datatype CLOSE_BRACKET {
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}
}))) (RULE extern_params (returns string p) (BLOCK (ALT ID {
        $p = $ID.text
}) (ALT UNDERSCORE {
        $p = $UNDERSCORE.text
}))) (RULE call_function (returns abstract.Instruction instr) (BLOCK (ALT ID OPEN_PARENTHESIS CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,[]interface{}{},$ID.line,$ID.pos)
}) (ALT ID OPEN_PARENTHESIS list_exp CLOSE_PARENTHESIS {
        $instr = instructions.NewCallFunction($ID.text,$list_exp.p,$ID.line,$ID.pos)
}))) (RULE list_exp (returns []interface{} p) (BLOCK (ALT expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,"_")
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT expression {
        value := instructions.NewParamCall($expression.p,"_")
        $p = []interface{}{value}
}) (ALT ID COLON expression COMMA list_exp {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = append([]interface{}{value},$list_exp.p...)
}) (ALT ID COLON expression {
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = []interface{}{value}
}))) (RULE call_function_exp (returns abstract.Expression p) (BLOCK (ALT call_function {
        $p = expressions.NewCallFunctionExp($call_function.instr)
}))) (RULE declare_array_bl (returns abstract.Instruction instr) (BLOCK (ALT VAR ID COLON type_matrix ASSIGN OPEN_BRACKET exp_matriz CLOSE_BRACKET {
        $instr = instructions.NewDeclareArray($ID.text,$type_matrix.td,$exp_matriz.p)
}))) (RULE exp_matriz (returns []interface{} p) (BLOCK (ALT expression {
        value := $expression.p
        $p = []interface{}{value}
}) (ALT expression COMMA exp_matriz { 
        value := $expression.p
        $p = append([]interface{}{value},$exp_matriz.p...)
}))) (RULE type_matrix (returns symbol.TypeData td) (BLOCK (ALT OPEN_BRACKET type_matrix CLOSE_BRACKET {
        $td = $type_matrix.td
}) (ALT OPEN_BRACKET datatype CLOSE_BRACKET {
        $td = $datatype.td
}))) (RULE definition_matrix (returns [][]interface{} p) (BLOCK (ALT type_matrix))) (RULE expression (returns abstract.Expression p) (BLOCK (ALT (= left expression) (= oper (SET MULTIPLICATION DIVISION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET SUMMATION SUBTRACTION)) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper MOD) (= right expression) {
                $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET LESS_THAN LESS_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET GREATER_THAN GREATER_THAN_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET EQUAL NOT_EQUAL)) (= right expression) {
                $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= left expression) (= oper (SET AND OR)) (= right expression) {
                $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper NOT) expression {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper '-') expression {
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        }) (ALT OPEN_PARENTHESIS expression CLOSE_PARENTHESIS {
                $p = $expression.p
        }) (ALT call_function_exp {
                $p = $call_function_exp.p
        }) (ALT native_function {
                $p = $native_function.p
        }) (ALT ID get_pos_matrix {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        }) (ALT ID OPEN_BRACKET expression CLOSE_BRACKET {
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        }) (ALT ID DOT COUNT {
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        }) (ALT ID DOT ISEMPTY {
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        }) (ALT OPEN_BRACKET array_exp CLOSE_BRACKET {
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        }) (ALT NUMBER {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        }) (ALT FLOATT {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        }) (ALT STRING_LITERAL {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        }) (ALT CHARACTER_LITERAL {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        }) (ALT TRUE {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        }) (ALT FALSE {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        }) (ALT ID {
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        }) (ALT NIL {
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        }))) (RULE datatype (returns symbol.TypeData td) (BLOCK (ALT INT {
                $td = symbol.INT
        }) (ALT FLOAT {
                $td = symbol.FLOAT
        }) (ALT STRING {
                $td = symbol.STRING
        }) (ALT BOOL {
                $td = symbol.BOOL
        }) (ALT CHARACTER {
                $td = symbol.CHAR
        })))))
2023-10-30 20:05:09:777 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftgrammLexer (@ header {
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"
}) (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"'))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE RANGE (BLOCK (ALT '...'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE OPEN_BRACKET (BLOCK (ALT '['))) (RULE CLOSE_BRACKET (BLOCK (ALT ']'))) (RULE ARROW (BLOCK (ALT '->'))) (RULE UNDERSCORE (BLOCK (ALT '_'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-10-30 20:05:09:801 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:09:950 left-recursion LogManager.java:25 expression returns [abstract.Expression p]
    :   ( {} oper = NOT<tokenIndex=1434> expression<tokenIndex=1436,p=18>{
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        } 
        | oper = '-'<tokenIndex=1445> expression<tokenIndex=1447,p=17>{
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        } 
        | OPEN_PARENTHESIS<tokenIndex=1452> expression<tokenIndex=1454> CLOSE_PARENTHESIS<tokenIndex=1456>{
                $p = $expression.p
        } 
        | call_function_exp<tokenIndex=1461>{
                $p = $call_function_exp.p
        } 
        | native_function<tokenIndex=1466>{
                $p = $native_function.p
        } 
        | ID<tokenIndex=1471> get_pos_matrix<tokenIndex=1473> {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        } 
        | ID<tokenIndex=1479> OPEN_BRACKET<tokenIndex=1481> expression<tokenIndex=1483> CLOSE_BRACKET<tokenIndex=1485>{
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        } 
        | ID<tokenIndex=1490> DOT<tokenIndex=1492> COUNT<tokenIndex=1494>{
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        } 
        | ID<tokenIndex=1499> DOT<tokenIndex=1501> ISEMPTY<tokenIndex=1503>{
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        } 
        | OPEN_BRACKET<tokenIndex=1508> array_exp<tokenIndex=1510> CLOSE_BRACKET<tokenIndex=1512>{
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        } 
        | NUMBER<tokenIndex=1517>{
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        } 
        | FLOATT<tokenIndex=1522>{
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        } 
        | STRING_LITERAL<tokenIndex=1527>{
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        } 
        | CHARACTER_LITERAL<tokenIndex=1532>{
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        } 
        | TRUE<tokenIndex=1537>{
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        } 
        | FALSE<tokenIndex=1542>{
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        } 
        | ID<tokenIndex=1547>{
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        } 
        | NIL<tokenIndex=1552>{
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 25)}?<p=25> oper=(MULTIPLICATION<tokenIndex=1308>|DIVISION<tokenIndex=1310>) right=expression<tokenIndex=1315,p=26>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 24)}?<p=24> oper=(SUMMATION<tokenIndex=1327>|SUBTRACTION<tokenIndex=1329>) right=expression<tokenIndex=1334,p=25>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 23)}?<p=23> oper=MOD<tokenIndex=1345> right=expression<tokenIndex=1349,p=24>{
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 22)}?<p=22> oper=(LESS_THAN<tokenIndex=1361>|LESS_THAN_EQUAL<tokenIndex=1363>) right=expression<tokenIndex=1368,p=23>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 21)}?<p=21> oper=(GREATER_THAN<tokenIndex=1380>|GREATER_THAN_EQUAL<tokenIndex=1382>) right=expression<tokenIndex=1387,p=22>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 20)}?<p=20> oper=(EQUAL<tokenIndex=1399>|NOT_EQUAL<tokenIndex=1401>) right=expression<tokenIndex=1406,p=21>{
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
                  | {p.Precpred(p.GetParserRuleContext(), 19)}?<p=19> oper=(AND<tokenIndex=1418>|OR<tokenIndex=1420>) right=expression<tokenIndex=1425,p=20>{
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }
        )*
    ;
2023-10-30 20:05:09:962 grammar LogManager.java:25 added: (RULE expression (returns abstract.Expression p) (BLOCK (ALT (BLOCK (ALT {} (= oper (NOT (ELEMENT_OPTIONS (= tokenIndex 1434)))) (expression (ELEMENT_OPTIONS (= tokenIndex 1436) (= p 18))) {
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        }) (ALT (= oper ('-' (ELEMENT_OPTIONS (= tokenIndex 1445)))) (expression (ELEMENT_OPTIONS (= tokenIndex 1447) (= p 17))) {
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        }) (ALT (OPEN_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 1452))) (expression (ELEMENT_OPTIONS (= tokenIndex 1454))) (CLOSE_PARENTHESIS (ELEMENT_OPTIONS (= tokenIndex 1456))) {
                $p = $expression.p
        }) (ALT (call_function_exp (ELEMENT_OPTIONS (= tokenIndex 1461))) {
                $p = $call_function_exp.p
        }) (ALT (native_function (ELEMENT_OPTIONS (= tokenIndex 1466))) {
                $p = $native_function.p
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1471))) (get_pos_matrix (ELEMENT_OPTIONS (= tokenIndex 1473))) {
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1479))) (OPEN_BRACKET (ELEMENT_OPTIONS (= tokenIndex 1481))) (expression (ELEMENT_OPTIONS (= tokenIndex 1483))) (CLOSE_BRACKET (ELEMENT_OPTIONS (= tokenIndex 1485))) {
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1490))) (DOT (ELEMENT_OPTIONS (= tokenIndex 1492))) (COUNT (ELEMENT_OPTIONS (= tokenIndex 1494))) {
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1499))) (DOT (ELEMENT_OPTIONS (= tokenIndex 1501))) (ISEMPTY (ELEMENT_OPTIONS (= tokenIndex 1503))) {
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        }) (ALT (OPEN_BRACKET (ELEMENT_OPTIONS (= tokenIndex 1508))) (array_exp (ELEMENT_OPTIONS (= tokenIndex 1510))) (CLOSE_BRACKET (ELEMENT_OPTIONS (= tokenIndex 1512))) {
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 1517))) {
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        }) (ALT (FLOATT (ELEMENT_OPTIONS (= tokenIndex 1522))) {
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        }) (ALT (STRING_LITERAL (ELEMENT_OPTIONS (= tokenIndex 1527))) {
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        }) (ALT (CHARACTER_LITERAL (ELEMENT_OPTIONS (= tokenIndex 1532))) {
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 1537))) {
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 1542))) {
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 1547))) {
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 1552))) {
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 25)}? (ELEMENT_OPTIONS (= p 25))) (= oper (SET (MULTIPLICATION (ELEMENT_OPTIONS (= tokenIndex 1308))) (DIVISION (ELEMENT_OPTIONS (= tokenIndex 1310))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1315) (= p 26)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 24)}? (ELEMENT_OPTIONS (= p 24))) (= oper (SET (SUMMATION (ELEMENT_OPTIONS (= tokenIndex 1327))) (SUBTRACTION (ELEMENT_OPTIONS (= tokenIndex 1329))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1334) (= p 25)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 23)}? (ELEMENT_OPTIONS (= p 23))) (= oper (MOD (ELEMENT_OPTIONS (= tokenIndex 1345)))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1349) (= p 24)))) {
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 22)}? (ELEMENT_OPTIONS (= p 22))) (= oper (SET (LESS_THAN (ELEMENT_OPTIONS (= tokenIndex 1361))) (LESS_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 1363))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1368) (= p 23)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 21)}? (ELEMENT_OPTIONS (= p 21))) (= oper (SET (GREATER_THAN (ELEMENT_OPTIONS (= tokenIndex 1380))) (GREATER_THAN_EQUAL (ELEMENT_OPTIONS (= tokenIndex 1382))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1387) (= p 22)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 20)}? (ELEMENT_OPTIONS (= p 20))) (= oper (SET (EQUAL (ELEMENT_OPTIONS (= tokenIndex 1399))) (NOT_EQUAL (ELEMENT_OPTIONS (= tokenIndex 1401))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1406) (= p 21)))) {
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }) (ALT ({p.Precpred(p.GetParserRuleContext(), 19)}? (ELEMENT_OPTIONS (= p 19))) (= oper (SET (AND (ELEMENT_OPTIONS (= tokenIndex 1418))) (OR (ELEMENT_OPTIONS (= tokenIndex 1420))))) (= right (expression (ELEMENT_OPTIONS (= tokenIndex 1425) (= p 20)))) {
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  }))))))
2023-10-30 20:05:09:966 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACTER=5, TRUE=6, FALSE=7, NIL=8, VAR=9, LET=10, PRINT=11, IF=12, ELSE=13, SWITCH=14, CASE=15, BREAK=16, DEFAULT=17, WHILE=18, FOR=19, IN=20, GUARD=21, CONTINUE=22, RETURN=23, FUNC=24, STRUCT=25, MUTATING=26, SELF=27, INOUT=28, APPEND=29, REMOVELAST=30, REMOVE=31, AT=32, ISEMPTY=33, COUNT=34, NUMBER=35, FLOATT=36, ID=37, CHARACTER_LITERAL=38, STRING_LITERAL=39, INCREMENT=40, DECREMENT=41, RANGE=42, SUMMATION=43, SUBTRACTION=44, MULTIPLICATION=45, DIVISION=46, MOD=47, QUESTION_MARK=48, OR=49, AND=50, NOT=51, EQUAL=52, NOT_EQUAL=53, LESS_THAN=54, LESS_THAN_EQUAL=55, GREATER_THAN=56, GREATER_THAN_EQUAL=57, ASSIGN=58, DOT=59, COMMA=60, COLON=61, SEMICOLON=62, OPEN_PARENTHESIS=63, CLOSE_PARENTHESIS=64, OPEN_kEY=65, CLOSE_kEY=66, OPEN_BRACKET=67, CLOSE_BRACKET=68, ARROW=69, UNDERSCORE=70, WHITESPACE=71, COMMENT=72, LINE_COMMENT=73}
2023-10-30 20:05:09:967 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'nil'=8, 'var'=9, 'let'=10, 'print'=11, 'if'=12, 'else'=13, 'switch'=14, 'case'=15, 'break'=16, 'default'=17, 'while'=18, 'for'=19, 'in'=20, 'guard'=21, 'continue'=22, 'return'=23, 'func'=24, 'struct'=25, 'mutating'=26, 'self'=27, 'inout'=28, 'append'=29, 'removeLast'=30, 'remove'=31, 'at'=32, 'IsEmpty'=33, 'count'=34, '+='=40, '-='=41, '...'=42, '+'=43, '-'=44, '*'=45, '/'=46, '%'=47, '?'=48, '||'=49, '&&'=50, '!'=51, '=='=52, '!='=53, '<'=54, '<='=55, '>'=56, '>='=57, '='=58, '.'=59, ','=60, ':'=61, ';'=62, '('=63, ')'=64, '{'=65, '}'=66, '['=67, ']'=68, '->'=69, '_'=70}
2023-10-30 20:05:10:010 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-10-30 20:05:10:011 LL1 LogManager.java:25 look=[{9..12, 14, 16, 18..19, 21..24, 37}, {<EOF>, 15, 17, 66}]
2023-10-30 20:05:10:011 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:10:011 LL1 LogManager.java:25 
DECISION 1 in rule sentence
2023-10-30 20:05:10:011 LL1 LogManager.java:25 look=[9, 10, 37, 37, 11, 12, 37, 37, 18, 19, 21, 16, 23, 22, 9, 24, 37, 37, 9, 14]
2023-10-30 20:05:10:011 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:011 LL1 LogManager.java:25 
DECISION 2 in rule get_pos_matrix
2023-10-30 20:05:10:011 LL1 LogManager.java:25 look=[67, 67]
2023-10-30 20:05:10:011 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:011 LL1 LogManager.java:25 
DECISION 3 in rule cases
2023-10-30 20:05:10:011 LL1 LogManager.java:25 look=[15, 15, 17]
2023-10-30 20:05:10:012 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:012 LL1 LogManager.java:25 
DECISION 4 in rule return_bl
2023-10-30 20:05:10:012 LL1 LogManager.java:25 look=[23, 23]
2023-10-30 20:05:10:012 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:012 LL1 LogManager.java:25 
DECISION 5 in rule declare_let
2023-10-30 20:05:10:012 LL1 LogManager.java:25 look=[10, 10]
2023-10-30 20:05:10:012 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:012 LL1 LogManager.java:25 
DECISION 6 in rule native_function
2023-10-30 20:05:10:012 LL1 LogManager.java:25 look=[3, 1, 2]
2023-10-30 20:05:10:012 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:10:012 LL1 LogManager.java:25 
DECISION 7 in rule declare_var
2023-10-30 20:05:10:012 LL1 LogManager.java:25 look=[9, 9, 9]
2023-10-30 20:05:10:012 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:012 LL1 LogManager.java:25 
DECISION 8 in rule list_print
2023-10-30 20:05:10:012 LL1 LogManager.java:25 look=[{1..3, 6..8, 35..39, 44, 51, 63, 67}, {1..3, 6..8, 35..39, 44, 51, 63, 67}]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 9 in rule if_bl
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[12, 12, 12]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 10 in rule else_if
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[13, 13, 13]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 11 in rule vector_bl
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[9, 9]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 12 in rule array_exp
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[{1..3, 6..8, 35..39, 44, 51, 63, 67}, {1..3, 6..8, 35..39, 44, 51, 63, 67}]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 13 in rule array_functions
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[37, 37, 37]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 14 in rule function_bl
2023-10-30 20:05:10:013 LL1 LogManager.java:25 look=[24, 24, 24, 24]
2023-10-30 20:05:10:013 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:013 LL1 LogManager.java:25 
DECISION 15 in rule params
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[37, 37, {37, 70}, {37, 70}, 37, 37, {37, 70}, {37, 70}]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 16 in rule extern_params
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[37, 70]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 17 in rule call_function
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[37, 37]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 18 in rule list_exp
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[{1..3, 6..8, 35..39, 44, 51, 63, 67}, {1..3, 6..8, 35..39, 44, 51, 63, 67}, 37, 37]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 19 in rule exp_matriz
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[{1..3, 6..8, 35..39, 44, 51, 63, 67}, {1..3, 6..8, 35..39, 44, 51, 63, 67}]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 20 in rule type_matrix
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[67, 67]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 21 in rule expression
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[51, 44, 63, 37, {1..3}, 37, 37, 37, 37, 67, 35, 36, 39, 38, 6, 7, 37, 8]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 22 in rule expression
2023-10-30 20:05:10:015 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null]
2023-10-30 20:05:10:015 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:015 LL1 LogManager.java:25 
DECISION 23 in rule expression
2023-10-30 20:05:10:016 LL1 LogManager.java:25 look=[null, null]
2023-10-30 20:05:10:016 LL1 LogManager.java:25 LL(1)? false
2023-10-30 20:05:10:016 LL1 LogManager.java:25 
DECISION 24 in rule datatype
2023-10-30 20:05:10:016 LL1 LogManager.java:25 look=[1, 2, 3, 4, 5]
2023-10-30 20:05:10:016 LL1 LogManager.java:25 LL(1)? true
2023-10-30 20:05:10:016 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:020 action-translator LogManager.java:25 translate 
        $code = $block.blk

2023-10-30 20:05:10:020 action-translator LogManager.java:25 attr [@-1,11:14='code',<0>,14:9]
2023-10-30 20:05:10:020 action-translator LogManager.java:25 qattr [@-1,19:23='block',<0>,14:17].[@-1,25:27='blk',<0>,14:23]
2023-10-30 20:05:10:022 action-translator LogManager.java:25 translate 
        $blk = []interface{}{}
        var listInt []ISentenceContext

2023-10-30 20:05:10:022 action-translator LogManager.java:25 attr [@-1,11:13='blk',<0>,20:9]
2023-10-30 20:05:10:024 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetInstr()
        for _,e := range listInt{
                $blk = append($blk,e.GetInstr())
        }

2023-10-30 20:05:10:024 action-translator LogManager.java:25 attr [@-1,109:111='blk',<0>,27:17]
2023-10-30 20:05:10:024 action-translator LogManager.java:25 attr [@-1,123:125='blk',<0>,27:31]
2023-10-30 20:05:10:025 action-translator LogManager.java:25 translate $instr = $declare_var.instr
2023-10-30 20:05:10:025 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,32:23]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 qattr [@-1,10:20='declare_var',<0>,32:32].[@-1,22:26='instr',<0>,32:44]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 translate $instr = $declare_let.instr
2023-10-30 20:05:10:026 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,33:23]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 qattr [@-1,10:20='declare_let',<0>,33:32].[@-1,22:26='instr',<0>,33:44]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 translate $instr = $assign_bl.instr
2023-10-30 20:05:10:026 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,34:21]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 qattr [@-1,10:18='assign_bl',<0>,34:30].[@-1,20:24='instr',<0>,34:40]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 translate $instr = $assign_vector.instr
2023-10-30 20:05:10:026 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,35:25]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 qattr [@-1,10:22='assign_vector',<0>,35:34].[@-1,24:28='instr',<0>,35:48]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 translate $instr = $print_bl.instr
2023-10-30 20:05:10:026 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,36:20]
2023-10-30 20:05:10:026 action-translator LogManager.java:25 qattr [@-1,10:17='print_bl',<0>,36:29].[@-1,19:23='instr',<0>,36:38]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 translate $instr = $if_bl.instr
2023-10-30 20:05:10:028 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,37:17]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 qattr [@-1,10:14='if_bl',<0>,37:26].[@-1,16:20='instr',<0>,37:32]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 translate $instr = $increment_bl.instr
2023-10-30 20:05:10:028 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,38:24]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 qattr [@-1,10:21='increment_bl',<0>,38:33].[@-1,23:27='instr',<0>,38:46]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 translate $instr = $decrement_bl.instr
2023-10-30 20:05:10:028 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,39:24]
2023-10-30 20:05:10:028 action-translator LogManager.java:25 qattr [@-1,10:21='decrement_bl',<0>,39:33].[@-1,23:27='instr',<0>,39:46]
2023-10-30 20:05:10:029 action-translator LogManager.java:25 translate $instr = $while_bl.instr
2023-10-30 20:05:10:029 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,40:20]
2023-10-30 20:05:10:029 action-translator LogManager.java:25 qattr [@-1,10:17='while_bl',<0>,40:29].[@-1,19:23='instr',<0>,40:38]
2023-10-30 20:05:10:029 action-translator LogManager.java:25 translate $instr = $for_bl.instr
2023-10-30 20:05:10:029 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,41:18]
2023-10-30 20:05:10:029 action-translator LogManager.java:25 qattr [@-1,10:15='for_bl',<0>,41:27].[@-1,17:21='instr',<0>,41:34]
2023-10-30 20:05:10:029 action-translator LogManager.java:25 translate $instr = $guard_bl.instr
2023-10-30 20:05:10:030 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,42:20]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 qattr [@-1,10:17='guard_bl',<0>,42:29].[@-1,19:23='instr',<0>,42:38]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 translate $instr = $break_bl.instr
2023-10-30 20:05:10:030 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,43:20]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 qattr [@-1,10:17='break_bl',<0>,43:29].[@-1,19:23='instr',<0>,43:38]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 translate $instr = $return_bl.instr
2023-10-30 20:05:10:030 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,44:21]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 qattr [@-1,10:18='return_bl',<0>,44:30].[@-1,20:24='instr',<0>,44:40]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 translate $instr = $continue_bl.instr
2023-10-30 20:05:10:030 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,45:23]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 qattr [@-1,10:20='continue_bl',<0>,45:32].[@-1,22:26='instr',<0>,45:44]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 translate $instr = $vector_bl.instr
2023-10-30 20:05:10:030 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,46:21]
2023-10-30 20:05:10:030 action-translator LogManager.java:25 qattr [@-1,10:18='vector_bl',<0>,46:30].[@-1,20:24='instr',<0>,46:40]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 translate $instr = $function_bl.instr
2023-10-30 20:05:10:031 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,47:23]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 qattr [@-1,10:20='function_bl',<0>,47:32].[@-1,22:26='instr',<0>,47:44]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 translate $instr = $call_function.instr
2023-10-30 20:05:10:031 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,48:25]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 qattr [@-1,10:22='call_function',<0>,48:34].[@-1,24:28='instr',<0>,48:48]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 translate $instr = $array_functions.instr
2023-10-30 20:05:10:031 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,49:27]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 qattr [@-1,10:24='array_functions',<0>,49:36].[@-1,26:30='instr',<0>,49:52]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 translate  $instr = $declare_array_bl.instr
2023-10-30 20:05:10:031 action-translator LogManager.java:25 attr [@-1,2:6='instr',<0>,50:29]
2023-10-30 20:05:10:031 action-translator LogManager.java:25 qattr [@-1,11:26='declare_array_bl',<0>,50:38].[@-1,28:32='instr',<0>,50:55]
2023-10-30 20:05:10:032 action-translator LogManager.java:25 translate $instr = $switch_bl.instr
2023-10-30 20:05:10:032 action-translator LogManager.java:25 attr [@-1,1:5='instr',<0>,51:21]
2023-10-30 20:05:10:032 action-translator LogManager.java:25 qattr [@-1,10:18='switch_bl',<0>,51:30].[@-1,20:24='instr',<0>,51:40]
2023-10-30 20:05:10:032 action-translator LogManager.java:25 translate 
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = append([]interface{}{exp},$get_pos_matrix.p...)

2023-10-30 20:05:10:032 action-translator LogManager.java:25 qattr [@-1,37:42='NUMBER',<0>,57:35].[@-1,44:47='text',<0>,57:42]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,175:180='NUMBER',<0>,61:55].[@-1,182:185='line',<0>,61:62]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,188:193='NUMBER',<0>,61:68].[@-1,195:197='pos',<0>,61:75]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 attr [@-1,210:210='p',<0>,62:9]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,241:254='get_pos_matrix',<0>,62:40].[@-1,256:256='p',<0>,62:55]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 translate 
        value,err := strconv.Atoi($NUMBER.text)
        if err != nil{
                fmt.Println(err)
        }
        exp := expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        $p = []interface{}{exp}

2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,37:42='NUMBER',<0>,65:35].[@-1,44:47='text',<0>,65:42]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,175:180='NUMBER',<0>,69:55].[@-1,182:185='line',<0>,69:62]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 qattr [@-1,188:193='NUMBER',<0>,69:68].[@-1,195:197='pos',<0>,69:75]
2023-10-30 20:05:10:033 action-translator LogManager.java:25 attr [@-1,210:210='p',<0>,70:9]
2023-10-30 20:05:10:035 action-translator LogManager.java:25 translate 
        $instr = instructions.NewSwitch($expression.p,$cases.p,$SWITCH.line,$SWITCH.pos)

2023-10-30 20:05:10:035 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,76:9]
2023-10-30 20:05:10:035 action-translator LogManager.java:25 qattr [@-1,43:52='expression',<0>,76:41].[@-1,54:54='p',<0>,76:52]
2023-10-30 20:05:10:035 action-translator LogManager.java:25 qattr [@-1,57:61='cases',<0>,76:55].[@-1,63:63='p',<0>,76:61]
2023-10-30 20:05:10:035 action-translator LogManager.java:25 qattr [@-1,66:71='SWITCH',<0>,76:64].[@-1,73:76='line',<0>,76:71]
2023-10-30 20:05:10:036 action-translator LogManager.java:25 qattr [@-1,79:84='SWITCH',<0>,76:77].[@-1,86:88='pos',<0>,76:84]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 translate 
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = append([]interface{}{value},$cases.p...)

2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,47:56='expression',<0>,83:45].[@-1,58:58='p',<0>,83:56]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,61:65='block',<0>,83:59].[@-1,67:69='blk',<0>,83:65]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,72:75='CASE',<0>,83:70].[@-1,77:80='line',<0>,83:75]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,83:86='CASE',<0>,83:81].[@-1,88:90='pos',<0>,83:86]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,84:9]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,136:140='cases',<0>,84:42].[@-1,142:142='p',<0>,84:48]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 translate 
        value := instructions.NewCaseSwitch($expression.p,$block.blk,$CASE.line,$CASE.pos)
        $p = []interface{}{value}

2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,47:56='expression',<0>,87:45].[@-1,58:58='p',<0>,87:56]
2023-10-30 20:05:10:037 action-translator LogManager.java:25 qattr [@-1,61:65='block',<0>,87:59].[@-1,67:69='blk',<0>,87:65]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 qattr [@-1,72:75='CASE',<0>,87:70].[@-1,77:80='line',<0>,87:75]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 qattr [@-1,83:86='CASE',<0>,87:81].[@-1,88:90='pos',<0>,87:86]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,88:9]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 translate 
        value := instructions.NewCaseSwitch(nil,$block.blk,$DEFAULT.line,$DEFAULT.pos)
        $p = []interface{}{value}       

2023-10-30 20:05:10:038 action-translator LogManager.java:25 qattr [@-1,51:55='block',<0>,93:49].[@-1,57:59='blk',<0>,93:55]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 qattr [@-1,62:68='DEFAULT',<0>,93:60].[@-1,70:73='line',<0>,93:68]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 qattr [@-1,76:82='DEFAULT',<0>,93:74].[@-1,84:86='pos',<0>,93:82]
2023-10-30 20:05:10:038 action-translator LogManager.java:25 attr [@-1,99:99='p',<0>,94:9]
2023-10-30 20:05:10:039 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIncreDecrem($ID.text,$INCREMENT.text,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:039 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,100:9]
2023-10-30 20:05:10:039 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,100:46].[@-1,51:54='text',<0>,100:49]
2023-10-30 20:05:10:041 action-translator LogManager.java:25 qattr [@-1,57:65='INCREMENT',<0>,100:55].[@-1,67:70='text',<0>,100:65]
2023-10-30 20:05:10:041 action-translator LogManager.java:25 qattr [@-1,73:82='expression',<0>,100:71].[@-1,84:84='p',<0>,100:82]
2023-10-30 20:05:10:041 action-translator LogManager.java:25 qattr [@-1,87:88='ID',<0>,100:85].[@-1,90:93='line',<0>,100:88]
2023-10-30 20:05:10:041 action-translator LogManager.java:25 qattr [@-1,96:97='ID',<0>,100:94].[@-1,99:101='pos',<0>,100:97]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIncreDecrem($ID.text,$DECREMENT.text,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:042 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,106:9]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,106:46].[@-1,51:54='text',<0>,106:49]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 qattr [@-1,57:65='DECREMENT',<0>,106:55].[@-1,67:70='text',<0>,106:65]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 qattr [@-1,73:82='expression',<0>,106:71].[@-1,84:84='p',<0>,106:82]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 qattr [@-1,87:88='ID',<0>,106:85].[@-1,90:93='line',<0>,106:88]
2023-10-30 20:05:10:042 action-translator LogManager.java:25 qattr [@-1,96:97='ID',<0>,106:94].[@-1,99:101='pos',<0>,106:97]
2023-10-30 20:05:10:043 action-translator LogManager.java:25 translate 
        $instr = instructions.NewBreak("break")

2023-10-30 20:05:10:043 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,112:9]
2023-10-30 20:05:10:043 action-translator LogManager.java:25 translate 
        $instr = instructions.NewReturn($expression.p)

2023-10-30 20:05:10:044 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,118:9]
2023-10-30 20:05:10:044 action-translator LogManager.java:25 qattr [@-1,43:52='expression',<0>,118:41].[@-1,54:54='p',<0>,118:52]
2023-10-30 20:05:10:044 action-translator LogManager.java:25 translate 
        $instr = instructions.NewReturn(expressions.NewNative(nil,symbol.NIL,$RETURN.line,$RETURN.pos))

2023-10-30 20:05:10:044 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,121:9]
2023-10-30 20:05:10:044 action-translator LogManager.java:25 qattr [@-1,80:85='RETURN',<0>,121:78].[@-1,87:90='line',<0>,121:85]
2023-10-30 20:05:10:044 action-translator LogManager.java:25 qattr [@-1,93:98='RETURN',<0>,121:91].[@-1,100:102='pos',<0>,121:98]
2023-10-30 20:05:10:045 action-translator LogManager.java:25 translate 
        $instr = instructions.NewContinue("continue")

2023-10-30 20:05:10:045 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,127:9]
2023-10-30 20:05:10:045 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:045 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,133:17]
2023-10-30 20:05:10:047 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,133:46].[@-1,51:54='text',<0>,133:49]
2023-10-30 20:05:10:047 action-translator LogManager.java:25 qattr [@-1,57:64='datatype',<0>,133:55].[@-1,66:67='td',<0>,133:64]
2023-10-30 20:05:10:047 action-translator LogManager.java:25 qattr [@-1,70:79='expression',<0>,133:68].[@-1,81:81='p',<0>,133:79]
2023-10-30 20:05:10:047 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,133:82].[@-1,87:90='line',<0>,133:85]
2023-10-30 20:05:10:047 action-translator LogManager.java:25 qattr [@-1,93:94='ID',<0>,133:91].[@-1,96:98='pos',<0>,133:94]
2023-10-30 20:05:10:048 action-translator LogManager.java:25 translate 
                $instr = instructions.NewLet($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:048 action-translator LogManager.java:25 attr [@-1,19:23='instr',<0>,136:17]
2023-10-30 20:05:10:048 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,136:46].[@-1,51:54='text',<0>,136:49]
2023-10-30 20:05:10:048 action-translator LogManager.java:25 qattr [@-1,74:83='expression',<0>,136:72].[@-1,85:85='p',<0>,136:83]
2023-10-30 20:05:10:048 action-translator LogManager.java:25 qattr [@-1,88:89='ID',<0>,136:86].[@-1,91:94='line',<0>,136:89]
2023-10-30 20:05:10:048 action-translator LogManager.java:25 qattr [@-1,97:98='ID',<0>,136:95].[@-1,100:102='pos',<0>,136:98]
2023-10-30 20:05:10:049 action-translator LogManager.java:25 translate 
        $p = expressions.NewNativeFunction($STRING.text,$expression.p)

2023-10-30 20:05:10:049 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,142:9]
2023-10-30 20:05:10:049 action-translator LogManager.java:25 qattr [@-1,46:51='STRING',<0>,142:44].[@-1,53:56='text',<0>,142:51]
2023-10-30 20:05:10:049 action-translator LogManager.java:25 qattr [@-1,59:68='expression',<0>,142:57].[@-1,70:70='p',<0>,142:68]
2023-10-30 20:05:10:049 action-translator LogManager.java:25 translate 
        $p = expressions.NewNativeFunction($INT.text,$expression.p)

2023-10-30 20:05:10:051 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,145:9]
2023-10-30 20:05:10:051 action-translator LogManager.java:25 qattr [@-1,46:48='INT',<0>,145:44].[@-1,50:53='text',<0>,145:48]
2023-10-30 20:05:10:051 action-translator LogManager.java:25 qattr [@-1,56:65='expression',<0>,145:54].[@-1,67:67='p',<0>,145:65]
2023-10-30 20:05:10:051 action-translator LogManager.java:25 translate 
        $p = expressions.NewNativeFunction($FLOAT.text,$expression.p)

2023-10-30 20:05:10:051 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,148:9]
2023-10-30 20:05:10:051 action-translator LogManager.java:25 qattr [@-1,46:50='FLOAT',<0>,148:44].[@-1,52:55='text',<0>,148:50]
2023-10-30 20:05:10:051 action-translator LogManager.java:25 qattr [@-1,58:67='expression',<0>,148:56].[@-1,69:69='p',<0>,148:67]
2023-10-30 20:05:10:052 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,$datatype.td,$expression.p,$ID.line,$ID.pos)
                
2023-10-30 20:05:10:052 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,155:25]
2023-10-30 20:05:10:052 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,155:67].[@-1,72:75='text',<0>,155:70]
2023-10-30 20:05:10:053 action-translator LogManager.java:25 qattr [@-1,78:85='datatype',<0>,155:76].[@-1,87:88='td',<0>,155:85]
2023-10-30 20:05:10:053 action-translator LogManager.java:25 qattr [@-1,91:100='expression',<0>,155:89].[@-1,102:102='p',<0>,155:100]
2023-10-30 20:05:10:053 action-translator LogManager.java:25 qattr [@-1,105:106='ID',<0>,155:103].[@-1,108:111='line',<0>,155:106]
2023-10-30 20:05:10:053 action-translator LogManager.java:25 qattr [@-1,114:115='ID',<0>,155:112].[@-1,117:119='pos',<0>,155:115]
2023-10-30 20:05:10:053 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithValue($ID.text,symbol.UNDEFINED,$expression.p,$ID.line,$ID.pos)
                
2023-10-30 20:05:10:054 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,158:25]
2023-10-30 20:05:10:054 action-translator LogManager.java:25 qattr [@-1,69:70='ID',<0>,158:67].[@-1,72:75='text',<0>,158:70]
2023-10-30 20:05:10:054 action-translator LogManager.java:25 qattr [@-1,95:104='expression',<0>,158:93].[@-1,106:106='p',<0>,158:104]
2023-10-30 20:05:10:054 action-translator LogManager.java:25 qattr [@-1,109:110='ID',<0>,158:107].[@-1,112:115='line',<0>,158:110]
2023-10-30 20:05:10:054 action-translator LogManager.java:25 qattr [@-1,118:119='ID',<0>,158:116].[@-1,121:123='pos',<0>,158:119]
2023-10-30 20:05:10:054 action-translator LogManager.java:25 translate 
                        $instr = instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$QUESTION_MARK.line,$QUESTION_MARK.pos),$ID.line,$ID.pos)
                
2023-10-30 20:05:10:054 action-translator LogManager.java:25 attr [@-1,27:31='instr',<0>,161:25]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,72:73='ID',<0>,161:70].[@-1,75:78='text',<0>,161:73]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,81:88='datatype',<0>,161:79].[@-1,90:91='td',<0>,161:88]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,131:143='QUESTION_MARK',<0>,161:129].[@-1,145:148='line',<0>,161:143]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,151:163='QUESTION_MARK',<0>,161:149].[@-1,165:167='pos',<0>,161:163]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,171:172='ID',<0>,161:169].[@-1,174:177='line',<0>,161:172]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,180:181='ID',<0>,161:178].[@-1,183:185='pos',<0>,161:181]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 translate 
        $instr = instructions.NewAsignVariable($ID.text,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:055 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,167:9]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,167:48].[@-1,53:56='text',<0>,167:51]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,59:68='expression',<0>,167:57].[@-1,70:70='p',<0>,167:68]
2023-10-30 20:05:10:055 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,167:71].[@-1,76:79='line',<0>,167:74]
2023-10-30 20:05:10:056 action-translator LogManager.java:25 qattr [@-1,82:83='ID',<0>,167:80].[@-1,85:87='pos',<0>,167:83]
2023-10-30 20:05:10:058 action-translator LogManager.java:25 translate 
        $instr = instructions.NewPrint($list_print.p)

2023-10-30 20:05:10:058 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,174:9]
2023-10-30 20:05:10:058 action-translator LogManager.java:25 qattr [@-1,42:51='list_print',<0>,174:40].[@-1,53:53='p',<0>,174:51]
2023-10-30 20:05:10:059 action-translator LogManager.java:25 translate 
        $p = append([]interface{}{$expression.p},$list_print.p...)

2023-10-30 20:05:10:059 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,180:9]
2023-10-30 20:05:10:059 action-translator LogManager.java:25 qattr [@-1,37:46='expression',<0>,180:35].[@-1,48:48='p',<0>,180:46]
2023-10-30 20:05:10:059 action-translator LogManager.java:25 qattr [@-1,52:61='list_print',<0>,180:50].[@-1,63:63='p',<0>,180:61]
2023-10-30 20:05:10:059 action-translator LogManager.java:25 translate 
        $p = []interface{}{$expression.p}

2023-10-30 20:05:10:059 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,183:9]
2023-10-30 20:05:10:059 action-translator LogManager.java:25 qattr [@-1,30:39='expression',<0>,183:28].[@-1,41:41='p',<0>,183:39]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,nil,$IF.line,$IF.pos)

2023-10-30 20:05:10:061 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,188:9]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,188:37].[@-1,50:50='p',<0>,188:48]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,188:51].[@-1,61:63='blk',<0>,188:59]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,70:71='IF',<0>,188:68].[@-1,73:76='line',<0>,188:71]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,79:80='IF',<0>,188:77].[@-1,82:84='pos',<0>,188:80]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$IF.line,$IF.pos)

2023-10-30 20:05:10:061 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,191:9]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,191:37].[@-1,50:50='p',<0>,191:48]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,191:51].[@-1,61:63='blk',<0>,191:59]
2023-10-30 20:05:10:061 action-translator LogManager.java:25 qattr [@-1,66:74='elseblock',<0>,191:64].[@-1,76:78='blk',<0>,191:74]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,81:82='IF',<0>,191:79].[@-1,84:87='line',<0>,191:82]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,90:91='IF',<0>,191:88].[@-1,93:95='pos',<0>,191:91]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 translate 
        $instr = instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$IF.line,$IF.pos)

2023-10-30 20:05:10:063 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,194:9]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,39:48='expression',<0>,194:37].[@-1,50:50='p',<0>,194:48]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,53:59='ifblock',<0>,194:51].[@-1,61:63='blk',<0>,194:59]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,66:72='else_if',<0>,194:64].[@-1,74:78='instr',<0>,194:72]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,81:82='IF',<0>,194:79].[@-1,84:87='line',<0>,194:82]
2023-10-30 20:05:10:063 action-translator LogManager.java:25 qattr [@-1,90:91='IF',<0>,194:88].[@-1,93:95='pos',<0>,194:91]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,nil,$ELSE.line,$ELSE.pos)}

2023-10-30 20:05:10:065 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,200:9]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,200:51].[@-1,64:64='p',<0>,200:62]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,200:65].[@-1,75:77='blk',<0>,200:73]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 qattr [@-1,84:87='ELSE',<0>,200:82].[@-1,89:92='line',<0>,200:87]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 qattr [@-1,95:98='ELSE',<0>,200:93].[@-1,100:102='pos',<0>,200:98]
2023-10-30 20:05:10:065 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$elseblock.blk,$ELSE.line,$ELSE.pos)}

2023-10-30 20:05:10:066 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,203:9]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,203:51].[@-1,64:64='p',<0>,203:62]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,203:65].[@-1,75:77='blk',<0>,203:73]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,80:88='elseblock',<0>,203:78].[@-1,90:92='blk',<0>,203:88]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,95:98='ELSE',<0>,203:93].[@-1,100:103='line',<0>,203:98]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,106:109='ELSE',<0>,203:104].[@-1,111:113='pos',<0>,203:109]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 translate 
        $instr = []interface{}{instructions.NewIf($expression.p,$ifblock.blk,$else_if.instr,$ELSE.line,$ELSE.pos)}

2023-10-30 20:05:10:066 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,206:9]
2023-10-30 20:05:10:066 action-translator LogManager.java:25 qattr [@-1,53:62='expression',<0>,206:51].[@-1,64:64='p',<0>,206:62]
2023-10-30 20:05:10:067 action-translator LogManager.java:25 qattr [@-1,67:73='ifblock',<0>,206:65].[@-1,75:77='blk',<0>,206:73]
2023-10-30 20:05:10:067 action-translator LogManager.java:25 qattr [@-1,80:86='else_if',<0>,206:78].[@-1,88:92='instr',<0>,206:86]
2023-10-30 20:05:10:067 action-translator LogManager.java:25 qattr [@-1,95:98='ELSE',<0>,206:93].[@-1,100:103='line',<0>,206:98]
2023-10-30 20:05:10:067 action-translator LogManager.java:25 qattr [@-1,106:109='ELSE',<0>,206:104].[@-1,111:113='pos',<0>,206:109]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 translate 
        $instr = instructions.NewWhile($expression.p,$block.blk,$WHILE.line,$WHILE.pos)

2023-10-30 20:05:10:068 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,211:9]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,211:40].[@-1,53:53='p',<0>,211:51]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 qattr [@-1,56:60='block',<0>,211:54].[@-1,62:64='blk',<0>,211:60]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 qattr [@-1,67:71='WHILE',<0>,211:65].[@-1,73:76='line',<0>,211:71]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 qattr [@-1,79:83='WHILE',<0>,211:77].[@-1,85:87='pos',<0>,211:83]
2023-10-30 20:05:10:068 action-translator LogManager.java:25 translate 
        $instr = instructions.NewFor($ID.text,$expression1.p,$expression2.p,$block.blk,$ID.line,$ID.pos)

2023-10-30 20:05:10:068 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,217:9]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,40:41='ID',<0>,217:38].[@-1,43:46='text',<0>,217:41]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,49:59='expression1',<0>,217:47].[@-1,61:61='p',<0>,217:59]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,64:74='expression2',<0>,217:62].[@-1,76:76='p',<0>,217:74]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,79:83='block',<0>,217:77].[@-1,85:87='blk',<0>,217:83]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,90:91='ID',<0>,217:88].[@-1,93:96='line',<0>,217:91]
2023-10-30 20:05:10:069 action-translator LogManager.java:25 qattr [@-1,99:100='ID',<0>,217:97].[@-1,102:104='pos',<0>,217:100]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 translate 
        $instr = instructions.NewGuard($expression.p,$block.blk,$GUARD.line,$GUARD.pos)

2023-10-30 20:05:10:071 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,223:9]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 qattr [@-1,42:51='expression',<0>,223:40].[@-1,53:53='p',<0>,223:51]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 qattr [@-1,56:60='block',<0>,223:54].[@-1,62:64='blk',<0>,223:60]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 qattr [@-1,67:71='GUARD',<0>,223:65].[@-1,73:76='line',<0>,223:71]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 qattr [@-1,79:83='GUARD',<0>,223:77].[@-1,85:87='pos',<0>,223:83]
2023-10-30 20:05:10:071 action-translator LogManager.java:25 translate 
        
        $instr = instructions.NewVector($ID.text,$datatype.td,$array_exp.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:072 action-translator LogManager.java:25 attr [@-1,21:25='instr',<0>,230:9]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,53:54='ID',<0>,230:41].[@-1,56:59='text',<0>,230:44]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,62:69='datatype',<0>,230:50].[@-1,71:72='td',<0>,230:59]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,75:83='array_exp',<0>,230:63].[@-1,85:85='p',<0>,230:73]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,88:89='ID',<0>,230:76].[@-1,91:94='line',<0>,230:79]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,97:98='ID',<0>,230:85].[@-1,100:102='pos',<0>,230:88]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 translate 
        
        $instr = instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos)

2023-10-30 20:05:10:072 action-translator LogManager.java:25 attr [@-1,21:25='instr',<0>,234:9]
2023-10-30 20:05:10:072 action-translator LogManager.java:25 qattr [@-1,53:54='ID',<0>,234:41].[@-1,56:59='text',<0>,234:44]
2023-10-30 20:05:10:073 action-translator LogManager.java:25 qattr [@-1,62:69='datatype',<0>,234:50].[@-1,71:72='td',<0>,234:59]
2023-10-30 20:05:10:073 action-translator LogManager.java:25 qattr [@-1,79:80='ID',<0>,234:67].[@-1,82:85='line',<0>,234:70]
2023-10-30 20:05:10:073 action-translator LogManager.java:25 qattr [@-1,88:89='ID',<0>,234:76].[@-1,91:93='pos',<0>,234:79]
2023-10-30 20:05:10:074 action-translator LogManager.java:25 translate 
        $p = append([]interface{}{$expression.p},$array_exp.p...)

2023-10-30 20:05:10:074 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,240:9]
2023-10-30 20:05:10:075 action-translator LogManager.java:25 qattr [@-1,37:46='expression',<0>,240:35].[@-1,48:48='p',<0>,240:46]
2023-10-30 20:05:10:075 action-translator LogManager.java:25 qattr [@-1,52:60='array_exp',<0>,240:50].[@-1,62:62='p',<0>,240:60]
2023-10-30 20:05:10:075 action-translator LogManager.java:25 translate 
        $p = []interface{}{$expression.p}
        

2023-10-30 20:05:10:075 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,243:9]
2023-10-30 20:05:10:075 action-translator LogManager.java:25 qattr [@-1,30:39='expression',<0>,243:28].[@-1,41:41='p',<0>,243:39]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 translate 
        $instr = instructions.NewArrayFunctions($ID.text,$APPEND.text,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:076 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,250:9]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,51:52='ID',<0>,250:49].[@-1,54:57='text',<0>,250:52]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,60:65='APPEND',<0>,250:58].[@-1,67:70='text',<0>,250:65]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,73:82='expression',<0>,250:71].[@-1,84:84='p',<0>,250:82]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,87:88='ID',<0>,250:85].[@-1,90:93='line',<0>,250:88]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,96:97='ID',<0>,250:94].[@-1,99:101='pos',<0>,250:97]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 translate 
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVELAST.text,nil,$ID.line,$ID.pos)

2023-10-30 20:05:10:076 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,253:9]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,51:52='ID',<0>,253:49].[@-1,54:57='text',<0>,253:52]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,60:69='REMOVELAST',<0>,253:58].[@-1,71:74='text',<0>,253:69]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,81:82='ID',<0>,253:79].[@-1,84:87='line',<0>,253:82]
2023-10-30 20:05:10:076 action-translator LogManager.java:25 qattr [@-1,90:91='ID',<0>,253:88].[@-1,93:95='pos',<0>,253:91]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 translate 
        $instr = instructions.NewArrayFunctions($ID.text,$REMOVE.text,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:078 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,256:9]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 qattr [@-1,51:52='ID',<0>,256:49].[@-1,54:57='text',<0>,256:52]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 qattr [@-1,60:65='REMOVE',<0>,256:58].[@-1,67:70='text',<0>,256:65]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 qattr [@-1,73:82='expression',<0>,256:71].[@-1,84:84='p',<0>,256:82]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 qattr [@-1,87:88='ID',<0>,256:85].[@-1,90:93='line',<0>,256:88]
2023-10-30 20:05:10:078 action-translator LogManager.java:25 qattr [@-1,96:97='ID',<0>,256:94].[@-1,99:101='pos',<0>,256:97]
2023-10-30 20:05:10:079 action-translator LogManager.java:25 translate 
        $instr = instructions.NewAsignVector($ID.text,$expression.p,$expression.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:079 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,262:9]
2023-10-30 20:05:10:079 action-translator LogManager.java:25 qattr [@-1,48:49='ID',<0>,262:46].[@-1,51:54='text',<0>,262:49]
2023-10-30 20:05:10:079 action-translator LogManager.java:25 qattr [@-1,57:66='expression',<0>,262:55].[@-1,68:68='p',<0>,262:66]
2023-10-30 20:05:10:079 action-translator LogManager.java:25 qattr [@-1,71:80='expression',<0>,262:69].[@-1,82:82='p',<0>,262:80]
2023-10-30 20:05:10:079 action-translator LogManager.java:25 qattr [@-1,85:86='ID',<0>,262:83].[@-1,88:91='line',<0>,262:86]
2023-10-30 20:05:10:081 action-translator LogManager.java:25 qattr [@-1,94:95='ID',<0>,262:92].[@-1,97:99='pos',<0>,262:95]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 translate 
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,[]interface{}{},$block.blk,$ID.line,$ID.pos)

2023-10-30 20:05:10:082 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,268:9]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,268:50].[@-1,55:58='text',<0>,268:53]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 qattr [@-1,61:68='datatype',<0>,268:59].[@-1,70:71='td',<0>,268:68]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 qattr [@-1,90:94='block',<0>,268:88].[@-1,96:98='blk',<0>,268:94]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 qattr [@-1,101:102='ID',<0>,268:99].[@-1,104:107='line',<0>,268:102]
2023-10-30 20:05:10:082 action-translator LogManager.java:25 qattr [@-1,110:111='ID',<0>,268:108].[@-1,113:115='pos',<0>,268:111]
2023-10-30 20:05:10:083 action-translator LogManager.java:25 translate 
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,[]interface{}{},$block.blk,$ID.line,$ID.pos)

2023-10-30 20:05:10:083 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,271:9]
2023-10-30 20:05:10:083 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,271:50].[@-1,55:58='text',<0>,271:53]
2023-10-30 20:05:10:083 action-translator LogManager.java:25 qattr [@-1,88:92='block',<0>,271:86].[@-1,94:96='blk',<0>,271:92]
2023-10-30 20:05:10:083 action-translator LogManager.java:25 qattr [@-1,99:100='ID',<0>,271:97].[@-1,102:105='line',<0>,271:100]
2023-10-30 20:05:10:083 action-translator LogManager.java:25 qattr [@-1,108:109='ID',<0>,271:106].[@-1,111:113='pos',<0>,271:109]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 translate 
        $instr = instructions.NewDeclareFunction($ID.text,$datatype.td,$params.p,$block.blk,$ID.line,$ID.pos)

2023-10-30 20:05:10:084 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,274:9]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,274:50].[@-1,55:58='text',<0>,274:53]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,61:68='datatype',<0>,274:59].[@-1,70:71='td',<0>,274:68]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,74:79='params',<0>,274:72].[@-1,81:81='p',<0>,274:79]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,84:88='block',<0>,274:82].[@-1,90:92='blk',<0>,274:88]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,95:96='ID',<0>,274:93].[@-1,98:101='line',<0>,274:96]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,104:105='ID',<0>,274:102].[@-1,107:109='pos',<0>,274:105]
2023-10-30 20:05:10:084 action-translator LogManager.java:25 translate 
        //fmt.Println($params.p)
        $instr = instructions.NewDeclareFunction($ID.text,symbol.NIL,$params.p,$block.blk,$ID.line,$ID.pos)

2023-10-30 20:05:10:084 action-translator LogManager.java:25 qattr [@-1,25:30='params',<0>,277:23].[@-1,32:32='p',<0>,277:30]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 attr [@-1,45:49='instr',<0>,278:9]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 qattr [@-1,86:87='ID',<0>,278:50].[@-1,89:92='text',<0>,278:53]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 qattr [@-1,106:111='params',<0>,278:70].[@-1,113:113='p',<0>,278:77]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 qattr [@-1,116:120='block',<0>,278:80].[@-1,122:124='blk',<0>,278:86]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 qattr [@-1,127:128='ID',<0>,278:91].[@-1,130:133='line',<0>,278:94]
2023-10-30 20:05:10:085 action-translator LogManager.java:25 qattr [@-1,136:137='ID',<0>,278:100].[@-1,139:141='pos',<0>,278:103]
2023-10-30 20:05:10:086 action-translator LogManager.java:25 translate 
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)


2023-10-30 20:05:10:086 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,284:82].[@-1,87:90='text',<0>,284:85]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,93:100='datatype',<0>,284:91].[@-1,102:103='td',<0>,284:100]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,143:144='ID',<0>,284:141].[@-1,146:149='line',<0>,284:144]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,152:153='ID',<0>,284:150].[@-1,155:157='pos',<0>,284:153]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,161:162='ID',<0>,284:159].[@-1,164:167='line',<0>,284:162]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,170:171='ID',<0>,284:168].[@-1,173:175='pos',<0>,284:171]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,179:180='ID',<0>,284:177].[@-1,182:185='text',<0>,284:180]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 attr [@-1,198:198='p',<0>,285:9]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,231:236='params',<0>,285:42].[@-1,238:238='p',<0>,285:49]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 translate 
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}

2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,86:87='ID',<0>,288:84].[@-1,89:92='text',<0>,288:87]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,95:102='datatype',<0>,288:93].[@-1,104:105='td',<0>,288:102]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,145:146='ID',<0>,288:143].[@-1,148:151='line',<0>,288:146]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,154:155='ID',<0>,288:152].[@-1,157:159='pos',<0>,288:155]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,163:164='ID',<0>,288:161].[@-1,166:169='line',<0>,288:164]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,172:173='ID',<0>,288:170].[@-1,175:177='pos',<0>,288:173]
2023-10-30 20:05:10:088 action-translator LogManager.java:25 qattr [@-1,181:182='ID',<0>,288:179].[@-1,184:187='text',<0>,288:182]
2023-10-30 20:05:10:089 action-translator LogManager.java:25 attr [@-1,200:200='p',<0>,289:9]
2023-10-30 20:05:10:089 action-translator LogManager.java:25 translate 
        value:=instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)


2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,292:82].[@-1,87:90='text',<0>,292:85]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,93:100='datatype',<0>,292:91].[@-1,102:103='td',<0>,292:100]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,143:144='ID',<0>,292:141].[@-1,146:149='line',<0>,292:144]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,152:153='ID',<0>,292:150].[@-1,155:157='pos',<0>,292:153]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,161:162='ID',<0>,292:159].[@-1,164:167='line',<0>,292:162]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,170:171='ID',<0>,292:168].[@-1,173:175='pos',<0>,292:171]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,179:191='extern_params',<0>,292:177].[@-1,193:196='text',<0>,292:191]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 attr [@-1,209:209='p',<0>,293:9]
2023-10-30 20:05:10:090 action-translator LogManager.java:25 qattr [@-1,242:247='params',<0>,293:42].[@-1,249:249='p',<0>,293:49]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 translate 
        value := instructions.NewParamFunction(instructions.NewDeclareWithoutValue($ID.text,$datatype.td,expressions.NewNative(nil,symbol.NIL,$ID.line,$ID.pos),$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}

2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,86:87='ID',<0>,296:84].[@-1,89:92='text',<0>,296:87]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,95:102='datatype',<0>,296:93].[@-1,104:105='td',<0>,296:102]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,145:146='ID',<0>,296:143].[@-1,148:151='line',<0>,296:146]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,154:155='ID',<0>,296:152].[@-1,157:159='pos',<0>,296:155]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,163:164='ID',<0>,296:161].[@-1,166:169='line',<0>,296:164]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,172:173='ID',<0>,296:170].[@-1,175:177='pos',<0>,296:173]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,181:193='extern_params',<0>,296:179].[@-1,195:198='text',<0>,296:193]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 attr [@-1,211:211='p',<0>,297:9]
2023-10-30 20:05:10:092 action-translator LogManager.java:25 translate 
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = append([]interface{}{value},$params.p...)


2023-10-30 20:05:10:092 action-translator LogManager.java:25 qattr [@-1,71:72='ID',<0>,299:69].[@-1,74:77='text',<0>,299:72]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,80:87='datatype',<0>,299:78].[@-1,89:90='td',<0>,299:87]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,97:98='ID',<0>,299:95].[@-1,100:103='line',<0>,299:98]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,106:107='ID',<0>,299:104].[@-1,109:111='pos',<0>,299:107]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,115:116='ID',<0>,299:113].[@-1,118:121='text',<0>,299:116]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 attr [@-1,134:134='p',<0>,300:9]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,167:172='params',<0>,300:42].[@-1,174:174='p',<0>,300:49]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 translate 
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$ID.text)
        $p = []interface{}{value}

2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,303:71].[@-1,76:79='text',<0>,303:74]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,82:89='datatype',<0>,303:80].[@-1,91:92='td',<0>,303:89]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,99:100='ID',<0>,303:97].[@-1,102:105='line',<0>,303:100]
2023-10-30 20:05:10:093 action-translator LogManager.java:25 qattr [@-1,108:109='ID',<0>,303:106].[@-1,111:113='pos',<0>,303:109]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,117:118='ID',<0>,303:115].[@-1,120:123='text',<0>,303:118]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 attr [@-1,136:136='p',<0>,304:9]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 translate 
        value:=instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = append([]interface{}{value},$params.p...)


2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,71:72='ID',<0>,307:69].[@-1,74:77='text',<0>,307:72]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,80:87='datatype',<0>,307:78].[@-1,89:90='td',<0>,307:87]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,97:98='ID',<0>,307:95].[@-1,100:103='line',<0>,307:98]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,106:107='ID',<0>,307:104].[@-1,109:111='pos',<0>,307:107]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 qattr [@-1,115:127='extern_params',<0>,307:113].[@-1,129:132='text',<0>,307:127]
2023-10-30 20:05:10:094 action-translator LogManager.java:25 attr [@-1,145:145='p',<0>,308:9]
2023-10-30 20:05:10:100 action-translator LogManager.java:25 qattr [@-1,178:183='params',<0>,308:42].[@-1,185:185='p',<0>,308:49]
2023-10-30 20:05:10:100 action-translator LogManager.java:25 translate 
        value := instructions.NewParamFunction(instructions.NewVector($ID.text,$datatype.td,nil,$ID.line,$ID.pos),$extern_params.text)
        $p = []interface{}{value}

2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,311:71].[@-1,76:79='text',<0>,311:74]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,82:89='datatype',<0>,311:80].[@-1,91:92='td',<0>,311:89]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,99:100='ID',<0>,311:97].[@-1,102:105='line',<0>,311:100]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,108:109='ID',<0>,311:106].[@-1,111:113='pos',<0>,311:109]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,117:129='extern_params',<0>,311:115].[@-1,131:134='text',<0>,311:129]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 attr [@-1,147:147='p',<0>,312:9]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 translate 
        $p = $ID.text

2023-10-30 20:05:10:101 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,318:9]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,16:17='ID',<0>,318:14].[@-1,19:22='text',<0>,318:17]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 translate 
        $p = $UNDERSCORE.text

2023-10-30 20:05:10:101 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,321:9]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 qattr [@-1,16:25='UNDERSCORE',<0>,321:14].[@-1,27:30='text',<0>,321:25]
2023-10-30 20:05:10:101 action-translator LogManager.java:25 translate 
        $instr = instructions.NewCallFunction($ID.text,[]interface{}{},$ID.line,$ID.pos)

2023-10-30 20:05:10:102 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,327:9]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,327:47].[@-1,52:55='text',<0>,327:50]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,74:75='ID',<0>,327:72].[@-1,77:80='line',<0>,327:75]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,83:84='ID',<0>,327:81].[@-1,86:88='pos',<0>,327:84]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 translate 
        $instr = instructions.NewCallFunction($ID.text,$list_exp.p,$ID.line,$ID.pos)

2023-10-30 20:05:10:102 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,330:9]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,330:47].[@-1,52:55='text',<0>,330:50]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,58:65='list_exp',<0>,330:56].[@-1,67:67='p',<0>,330:65]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,70:71='ID',<0>,330:68].[@-1,73:76='line',<0>,330:71]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,79:80='ID',<0>,330:77].[@-1,82:84='pos',<0>,330:80]
2023-10-30 20:05:10:102 action-translator LogManager.java:25 translate 
        value := instructions.NewParamCall($expression.p,"_")
        $p = append([]interface{}{value},$list_exp.p...)

2023-10-30 20:05:10:102 action-translator LogManager.java:25 qattr [@-1,46:55='expression',<0>,336:44].[@-1,57:57='p',<0>,336:55]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 attr [@-1,74:74='p',<0>,337:9]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,107:114='list_exp',<0>,337:42].[@-1,116:116='p',<0>,337:51]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 translate 
        value := instructions.NewParamCall($expression.p,"_")
        $p = []interface{}{value}

2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,46:55='expression',<0>,340:44].[@-1,57:57='p',<0>,340:55]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 attr [@-1,74:74='p',<0>,341:9]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 translate 
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = append([]interface{}{value},$list_exp.p...)

2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,46:55='expression',<0>,344:44].[@-1,57:57='p',<0>,344:55]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,60:61='ID',<0>,344:58].[@-1,63:66='text',<0>,344:61]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 attr [@-1,79:79='p',<0>,345:9]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,112:119='list_exp',<0>,345:42].[@-1,121:121='p',<0>,345:51]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 translate 
        value := instructions.NewParamCall($expression.p,$ID.text)
        $p = []interface{}{value}

2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,46:55='expression',<0>,348:44].[@-1,57:57='p',<0>,348:55]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,60:61='ID',<0>,348:58].[@-1,63:66='text',<0>,348:61]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 attr [@-1,79:79='p',<0>,349:9]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 translate 
        $p = expressions.NewCallFunctionExp($call_function.instr)

2023-10-30 20:05:10:103 action-translator LogManager.java:25 attr [@-1,11:11='p',<0>,355:9]
2023-10-30 20:05:10:103 action-translator LogManager.java:25 qattr [@-1,47:59='call_function',<0>,355:45].[@-1,61:65='instr',<0>,355:59]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 translate 
        $instr = instructions.NewDeclareArray($ID.text,$type_matrix.td,$exp_matriz.p)

2023-10-30 20:05:10:105 action-translator LogManager.java:25 attr [@-1,11:15='instr',<0>,361:9]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 qattr [@-1,49:50='ID',<0>,361:47].[@-1,52:55='text',<0>,361:50]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 qattr [@-1,58:68='type_matrix',<0>,361:56].[@-1,70:71='td',<0>,361:68]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 qattr [@-1,74:83='exp_matriz',<0>,361:72].[@-1,85:85='p',<0>,361:83]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 translate 
        value := $expression.p
        $p = []interface{}{value}

2023-10-30 20:05:10:105 action-translator LogManager.java:25 qattr [@-1,20:29='expression',<0>,367:18].[@-1,31:31='p',<0>,367:29]
2023-10-30 20:05:10:105 action-translator LogManager.java:25 attr [@-1,43:43='p',<0>,368:9]
2023-10-30 20:05:10:106 action-translator LogManager.java:25 translate  
        value := $expression.p
        $p = append([]interface{}{value},$exp_matriz.p...)

2023-10-30 20:05:10:106 action-translator LogManager.java:25 qattr [@-1,21:30='expression',<0>,371:18].[@-1,32:32='p',<0>,371:29]
2023-10-30 20:05:10:106 action-translator LogManager.java:25 attr [@-1,44:44='p',<0>,372:9]
2023-10-30 20:05:10:106 action-translator LogManager.java:25 qattr [@-1,77:86='exp_matriz',<0>,372:42].[@-1,88:88='p',<0>,372:53]
2023-10-30 20:05:10:106 action-translator LogManager.java:25 translate 
        $td = $type_matrix.td

2023-10-30 20:05:10:107 action-translator LogManager.java:25 attr [@-1,11:12='td',<0>,378:9]
2023-10-30 20:05:10:107 action-translator LogManager.java:25 qattr [@-1,17:27='type_matrix',<0>,378:15].[@-1,29:30='td',<0>,378:27]
2023-10-30 20:05:10:107 action-translator LogManager.java:25 translate 
        $td = $datatype.td

2023-10-30 20:05:10:107 action-translator LogManager.java:25 attr [@-1,11:12='td',<0>,380:9]
2023-10-30 20:05:10:107 action-translator LogManager.java:25 qattr [@-1,17:24='datatype',<0>,380:15].[@-1,26:27='td',<0>,380:24]
2023-10-30 20:05:10:108 action-translator LogManager.java:25 translate 
2023-10-30 20:05:10:108 action-translator LogManager.java:25 translate 
                $p = expressions.NewLogicOperations(nil,$expression.p,$oper.text,$oper.line,$oper.pos)
        
2023-10-30 20:05:10:108 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,3:17]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,59:68='expression',<0>,3:57].[@-1,70:70='p',<0>,3:68]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,73:76='oper',<0>,3:71].[@-1,78:81='text',<0>,3:76]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,84:87='oper',<0>,3:82].[@-1,89:92='line',<0>,3:87]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,95:98='oper',<0>,3:93].[@-1,100:102='pos',<0>,3:98]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 translate 
                $p = expressions.NewNegative($expression.p,$oper.line,$oper.pos)
        
2023-10-30 20:05:10:109 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,6:17]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,48:57='expression',<0>,6:46].[@-1,59:59='p',<0>,6:57]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,62:65='oper',<0>,6:60].[@-1,67:70='line',<0>,6:65]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,73:76='oper',<0>,6:71].[@-1,78:80='pos',<0>,6:76]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 translate 
                $p = $expression.p
        
2023-10-30 20:05:10:109 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,9:17]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 qattr [@-1,24:33='expression',<0>,9:22].[@-1,35:35='p',<0>,9:33]
2023-10-30 20:05:10:109 action-translator LogManager.java:25 translate 
                $p = $call_function_exp.p
        
2023-10-30 20:05:10:109 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,12:17]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,24:40='call_function_exp',<0>,12:22].[@-1,42:42='p',<0>,12:40]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 translate 
                $p = $native_function.p
        
2023-10-30 20:05:10:111 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,15:17]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,24:38='native_function',<0>,15:22].[@-1,40:40='p',<0>,15:38]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 translate 
                $p = expressions.NewGetPosMatrix($ID.text,$get_pos_matrix.p,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:111 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,18:17]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,18:50].[@-1,55:58='text',<0>,18:53]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,61:74='get_pos_matrix',<0>,18:59].[@-1,76:76='p',<0>,18:74]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,79:80='ID',<0>,18:77].[@-1,82:85='line',<0>,18:80]
2023-10-30 20:05:10:111 action-translator LogManager.java:25 qattr [@-1,88:89='ID',<0>,18:86].[@-1,91:93='pos',<0>,18:89]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 translate 
                $p = expressions.NewGetPosVector($ID.text,$expression.p,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:112 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,21:17]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,21:50].[@-1,55:58='text',<0>,21:53]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 qattr [@-1,61:70='expression',<0>,21:59].[@-1,72:72='p',<0>,21:70]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 qattr [@-1,75:76='ID',<0>,21:73].[@-1,78:81='line',<0>,21:76]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,21:82].[@-1,87:89='pos',<0>,21:85]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 translate 
                $p = expressions.NewVectorValues($ID.text,$COUNT.text,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:112 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,24:17]
2023-10-30 20:05:10:112 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,24:50].[@-1,55:58='text',<0>,24:53]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,61:65='COUNT',<0>,24:59].[@-1,67:70='text',<0>,24:65]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,73:74='ID',<0>,24:71].[@-1,76:79='line',<0>,24:74]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,82:83='ID',<0>,24:80].[@-1,85:87='pos',<0>,24:83]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 translate 
                $p = expressions.NewVectorValues($ID.text,$ISEMPTY.text,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:113 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,27:17]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,52:53='ID',<0>,27:50].[@-1,55:58='text',<0>,27:53]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,61:67='ISEMPTY',<0>,27:59].[@-1,69:72='text',<0>,27:67]
2023-10-30 20:05:10:113 action-translator LogManager.java:25 qattr [@-1,75:76='ID',<0>,27:73].[@-1,78:81='line',<0>,27:76]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,84:85='ID',<0>,27:82].[@-1,87:89='pos',<0>,27:85]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 translate 
                $p = expressions.NewNative($array_exp.p,symbol.ARRAY,$OPEN_BRACKET.line,$OPEN_BRACKET.pos)
        
2023-10-30 20:05:10:114 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,30:17]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,46:54='array_exp',<0>,30:44].[@-1,56:56='p',<0>,30:54]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,72:83='OPEN_BRACKET',<0>,30:70].[@-1,85:88='line',<0>,30:83]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,91:102='OPEN_BRACKET',<0>,30:89].[@-1,104:106='pos',<0>,30:102]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 translate 
                value,err := strconv.Atoi($NUMBER.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.INT,$NUMBER.line,$NUMBER.pos)
        
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,45:50='NUMBER',<0>,33:43].[@-1,52:55='text',<0>,33:50]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 attr [@-1,169:169='p',<0>,37:17]
2023-10-30 20:05:10:114 action-translator LogManager.java:25 qattr [@-1,213:218='NUMBER',<0>,37:61].[@-1,220:223='line',<0>,37:68]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,226:231='NUMBER',<0>,37:74].[@-1,233:235='pos',<0>,37:81]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseFloat($FLOATT.text,64)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.FLOAT,$FLOATT.line,$FLOATT.pos)
        
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,51:56='FLOATT',<0>,40:49].[@-1,58:61='text',<0>,40:56]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 attr [@-1,178:178='p',<0>,44:17]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,224:229='FLOATT',<0>,44:63].[@-1,231:234='line',<0>,44:70]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,237:242='FLOATT',<0>,44:76].[@-1,244:246='pos',<0>,44:83]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 translate 
                value := $STRING_LITERAL.text[1:len($STRING_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.STRING,$STRING_LITERAL.line,$STRING_LITERAL.pos)
        
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,28:41='STRING_LITERAL',<0>,47:26].[@-1,43:46='text',<0>,47:41]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,55:68='STRING_LITERAL',<0>,47:53].[@-1,70:73='text',<0>,47:68]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 attr [@-1,97:97='p',<0>,48:17]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,144:157='STRING_LITERAL',<0>,48:64].[@-1,159:162='line',<0>,48:79]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,165:178='STRING_LITERAL',<0>,48:85].[@-1,180:182='pos',<0>,48:100]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 translate 
                value := $CHARACTER_LITERAL.text[1:len($CHARACTER_LITERAL.text)-1]
                $p = expressions.NewNative(value,symbol.CHAR,$CHARACTER_LITERAL.line,$CHARACTER_LITERAL.pos)
        
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,28:44='CHARACTER_LITERAL',<0>,51:26].[@-1,46:49='text',<0>,51:44]
2023-10-30 20:05:10:115 action-translator LogManager.java:25 qattr [@-1,58:74='CHARACTER_LITERAL',<0>,51:56].[@-1,76:79='text',<0>,51:74]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 attr [@-1,103:103='p',<0>,52:17]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,148:164='CHARACTER_LITERAL',<0>,52:62].[@-1,166:169='line',<0>,52:80]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,172:188='CHARACTER_LITERAL',<0>,52:86].[@-1,190:192='pos',<0>,52:104]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($TRUE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$TRUE.line,$TRUE.pos) 
        
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,50:53='TRUE',<0>,55:48].[@-1,55:58='text',<0>,55:53]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 attr [@-1,172:172='p',<0>,59:17]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,217:220='TRUE',<0>,59:62].[@-1,222:225='line',<0>,59:67]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,228:231='TRUE',<0>,59:73].[@-1,233:235='pos',<0>,59:78]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 translate 
                value,err := strconv.ParseBool($FALSE.text)
                if err != nil{
                        fmt.Println(err)
                }
                $p = expressions.NewNative(value,symbol.BOOL,$FALSE.line,$FALSE.pos) 
        
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,50:54='FALSE',<0>,62:48].[@-1,56:59='text',<0>,62:54]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 attr [@-1,173:173='p',<0>,66:17]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,218:222='FALSE',<0>,66:62].[@-1,224:227='line',<0>,66:68]
2023-10-30 20:05:10:116 action-translator LogManager.java:25 qattr [@-1,230:234='FALSE',<0>,66:74].[@-1,236:238='pos',<0>,66:80]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 translate 
                $p = expressions.NewIdentifier($ID.text,$ID.line,$ID.pos)
        
2023-10-30 20:05:10:117 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,69:17]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 qattr [@-1,50:51='ID',<0>,69:48].[@-1,53:56='text',<0>,69:51]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 qattr [@-1,59:60='ID',<0>,69:57].[@-1,62:65='line',<0>,69:60]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 qattr [@-1,68:69='ID',<0>,69:66].[@-1,71:73='pos',<0>,69:69]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 translate 
                $p = expressions.NewNative(nil,symbol.NIL,$NIL.line,$NIL.pos)
        
2023-10-30 20:05:10:117 action-translator LogManager.java:25 attr [@-1,19:19='p',<0>,72:17]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 qattr [@-1,61:63='NIL',<0>,72:59].[@-1,65:68='line',<0>,72:63]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 qattr [@-1,71:73='NIL',<0>,72:69].[@-1,75:77='pos',<0>,72:73]
2023-10-30 20:05:10:117 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 25)
2023-10-30 20:05:10:117 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:118 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,77:27]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,77:68].[@-1,75:75='p',<0>,77:73]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,77:76].[@-1,84:84='p',<0>,77:82]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,77:85].[@-1,92:95='text',<0>,77:90]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,77:96].[@-1,103:106='line',<0>,77:101]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,77:107].[@-1,114:116='pos',<0>,77:112]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 24)
2023-10-30 20:05:10:118 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:118 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,80:27]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,80:68].[@-1,75:75='p',<0>,80:73]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,80:76].[@-1,84:84='p',<0>,80:82]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,80:85].[@-1,92:95='text',<0>,80:90]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,80:96].[@-1,103:106='line',<0>,80:101]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,80:107].[@-1,114:116='pos',<0>,80:112]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 23)
2023-10-30 20:05:10:118 action-translator LogManager.java:25 translate 
                          $p = expressions.NewArithmeticOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:118 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,83:27]
2023-10-30 20:05:10:118 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,83:68].[@-1,75:75='p',<0>,83:73]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,83:76].[@-1,84:84='p',<0>,83:82]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,83:85].[@-1,92:95='text',<0>,83:90]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,83:96].[@-1,103:106='line',<0>,83:101]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,83:107].[@-1,114:116='pos',<0>,83:112]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 22)
2023-10-30 20:05:10:119 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:119 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,86:27]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,86:68].[@-1,75:75='p',<0>,86:73]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,86:76].[@-1,84:84='p',<0>,86:82]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,86:85].[@-1,92:95='text',<0>,86:90]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,86:96].[@-1,103:106='line',<0>,86:101]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,86:107].[@-1,114:116='pos',<0>,86:112]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 21)
2023-10-30 20:05:10:119 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:119 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,89:27]
2023-10-30 20:05:10:119 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,89:68].[@-1,75:75='p',<0>,89:73]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,89:76].[@-1,84:84='p',<0>,89:82]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,89:85].[@-1,92:95='text',<0>,89:90]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,89:96].[@-1,103:106='line',<0>,89:101]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,89:107].[@-1,114:116='pos',<0>,89:112]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 20)
2023-10-30 20:05:10:121 action-translator LogManager.java:25 translate 
                          $p = expressions.NewRelationalOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:121 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,92:27]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,70:73='left',<0>,92:68].[@-1,75:75='p',<0>,92:73]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,78:82='right',<0>,92:76].[@-1,84:84='p',<0>,92:82]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,87:90='oper',<0>,92:85].[@-1,92:95='text',<0>,92:90]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,98:101='oper',<0>,92:96].[@-1,103:106='line',<0>,92:101]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 qattr [@-1,109:112='oper',<0>,92:107].[@-1,114:116='pos',<0>,92:112]
2023-10-30 20:05:10:121 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 19)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate 
                          $p = expressions.NewLogicOperations($left.p,$right.p,$oper.text,$oper.line,$oper.pos)
                  
2023-10-30 20:05:10:122 action-translator LogManager.java:25 attr [@-1,29:29='p',<0>,95:27]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 qattr [@-1,65:68='left',<0>,95:63].[@-1,70:70='p',<0>,95:68]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 qattr [@-1,73:77='right',<0>,95:71].[@-1,79:79='p',<0>,95:77]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 qattr [@-1,82:85='oper',<0>,95:80].[@-1,87:90='text',<0>,95:85]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 qattr [@-1,93:96='oper',<0>,95:91].[@-1,98:101='line',<0>,95:96]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 qattr [@-1,104:107='oper',<0>,95:102].[@-1,109:111='pos',<0>,95:107]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 25)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 24)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 23)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 22)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 21)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 20)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 19)
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate 
                $td = symbol.INT
        
2023-10-30 20:05:10:122 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,490:17]
2023-10-30 20:05:10:122 action-translator LogManager.java:25 translate 
                $td = symbol.FLOAT
        
2023-10-30 20:05:10:122 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,493:17]
2023-10-30 20:05:10:123 action-translator LogManager.java:25 translate 
                $td = symbol.STRING
        
2023-10-30 20:05:10:123 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,496:17]
2023-10-30 20:05:10:123 action-translator LogManager.java:25 translate 
                $td = symbol.BOOL
        
2023-10-30 20:05:10:123 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,499:17]
2023-10-30 20:05:10:123 action-translator LogManager.java:25 translate 
                $td = symbol.CHAR
        
2023-10-30 20:05:10:123 action-translator LogManager.java:25 attr [@-1,19:20='td',<0>,502:17]
2023-10-30 20:05:10:610 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:610 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:699 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:699 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:791 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:791 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:860 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:860 action-translator LogManager.java:25 translate 
        import "grammar/expressions"
        import "grammar/instructions"
        import "grammar/symbol"
        import "grammar/abstract"

2023-10-30 20:05:10:946 grammar LogManager.java:25 before: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"'))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE RANGE (BLOCK (ALT '...'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE OPEN_BRACKET (BLOCK (ALT '['))) (RULE CLOSE_BRACKET (BLOCK (ALT ']'))) (RULE ARROW (BLOCK (ALT '->'))) (RULE UNDERSCORE (BLOCK (ALT '_'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-10-30 20:05:10:951 grammar LogManager.java:25 after: (LEXER_GRAMMAR Swiftlex (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACTER (BLOCK (ALT 'Character'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9])))))) (RULE FLOATT (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER_LITERAL (BLOCK (ALT '"' (BLOCK (ALT (~ (SET ["])))) '"'))) (RULE STRING_LITERAL (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE INCREMENT (BLOCK (ALT '+='))) (RULE DECREMENT (BLOCK (ALT '-='))) (RULE RANGE (BLOCK (ALT '...'))) (RULE SUMMATION (BLOCK (ALT '+'))) (RULE SUBTRACTION (BLOCK (ALT '-'))) (RULE MULTIPLICATION (BLOCK (ALT '*'))) (RULE DIVISION (BLOCK (ALT '/'))) (RULE MOD (BLOCK (ALT '%'))) (RULE QUESTION_MARK (BLOCK (ALT '?'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE NOT (BLOCK (ALT '!'))) (RULE EQUAL (BLOCK (ALT '=='))) (RULE NOT_EQUAL (BLOCK (ALT '!='))) (RULE LESS_THAN (BLOCK (ALT '<'))) (RULE LESS_THAN_EQUAL (BLOCK (ALT '<='))) (RULE GREATER_THAN (BLOCK (ALT '>'))) (RULE GREATER_THAN_EQUAL (BLOCK (ALT '>='))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE DOT (BLOCK (ALT '.'))) (RULE COMMA (BLOCK (ALT ','))) (RULE COLON (BLOCK (ALT ':'))) (RULE SEMICOLON (BLOCK (ALT ';'))) (RULE OPEN_PARENTHESIS (BLOCK (ALT '('))) (RULE CLOSE_PARENTHESIS (BLOCK (ALT ')'))) (RULE OPEN_kEY (BLOCK (ALT '{'))) (RULE CLOSE_kEY (BLOCK (ALT '}'))) (RULE OPEN_BRACKET (BLOCK (ALT '['))) (RULE CLOSE_BRACKET (BLOCK (ALT ']'))) (RULE ARROW (BLOCK (ALT '->'))) (RULE UNDERSCORE (BLOCK (ALT '_'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
